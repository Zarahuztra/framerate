[
  {
    "id": "js-advanced-closures-001",
    "title": "Understanding Closures and Scope",
    "difficulty": "advanced",
    "framework": "JavaScript",
    "frameworkIconText": "JS",
    "tags": ["closures", "scope", "functions", "lexical environment"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function's scope from an inner function, even after the outer function has finished executing."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "function createCounter() {\n  let count = 0;\n  return function() {\n    count++;\n    return count;\n  };\n}\n\nconst counter1 = createCounter();\nconsole.log(counter1()); // Output: 1\nconsole.log(counter1()); // Output: 2\n\nconst counter2 = createCounter();\nconsole.log(counter2()); // Output: 1"
      },
      {
        "type": "explanation",
        "text": "Each call to `createCounter()` creates a new lexical environment with its own `count` variable. The inner function 'remembers' this `count` due to closure. `counter1` and `counter2` have independent counts."
      }
    ],
    "quiz": {
      "snippet": "function outer() {\n  let x = 10;\n  return function inner(y) {\n    return x + y;\n  };\n}\nconst addToX = outer();\nconsole.log(addToX(5));",
      "questionText": "What will be logged to the console?",
      "options": ["5", "10", "15", "Error"],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "The `inner` function forms a closure over `x` from `outer`'s scope. When `addToX(5)` is called, `x` is 10 (from the closure) and `y` is 5, so it returns 15."
    }
  },
  {
    "id": "js-advanced-promises-async-002",
    "title": "Asynchronous Operations with Promises",
    "difficulty": "advanced",
    "framework": "JavaScript",
    "frameworkIconText": "JS",
    "tags": ["promises", "asynchronous", "async/await", "event loop"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Promises are used for asynchronous computations. A Promise represents a value which may be available now, or in the future, or never. `async/await` syntax provides a cleaner way to work with promises."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "function fetchData() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(\"Data fetched!\");\n      // reject(\"Error fetching data!\"); // Uncomment to simulate an error\n    }, 1000);\n  });\n}\n\nasync function processData() {\n  console.log(\"Starting data processing...\");\n  try {\n    const data = await fetchData();\n    console.log(data);\n  } catch (error) {\n    console.error(error);\n  }\n  console.log(\"Data processing finished.\");\n}\n\nprocessData();\n// Output order: \n// Starting data processing...\n// Data processing finished.\n// Data fetched! (after ~1 second)"
      },
      {
        "type": "explanation",
        "text": "`fetchData` returns a promise that resolves after 1 second. `await` in `processData` pauses execution until the promise resolves. Note that 'Data processing finished.' logs before 'Data fetched!' because `await` only pauses `processData`, not the entire program."
      }
    ],
    "quiz": {
      "snippet": "console.log(1);\nsetTimeout(() => console.log(2), 0);\nPromise.resolve().then(() => console.log(3));\nconsole.log(4);",
      "questionText": "What is the order of logs to the console?",
      "options": ["1, 2, 3, 4", "1, 4, 2, 3", "1, 4, 3, 2", "1, 3, 4, 2"],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Synchronous code (1, 4) runs first. Promise microtasks (3) run before macrotasks like setTimeout (2), even with a 0ms delay. So the order is 1, 4, 3, 2."
    }
  },
  {
    "id": "js-advanced-this-binding-003",
    "title": "`this` Keyword and Binding",
    "difficulty": "advanced",
    "framework": "JavaScript",
    "frameworkIconText": "JS",
    "tags": ["this", "binding", "call", "apply", "bind", "arrow functions"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "The value of `this` in JavaScript depends on how a function is called (its invocation context). Understanding `this` is crucial for object-oriented programming and event handling."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "const person = {\n  name: \"Alex\",\n  greet: function() {\n    console.log(`Hello, I am ${this.name}`);\n  }\n};\n\nconst greetFunc = person.greet;\ngreetFunc(); // Output: Hello, I am undefined (or window.name in browsers in non-strict mode)\n\nperson.greet.call({ name: \"Bob\" }); // Output: Hello, I am Bob\n\nconst boundGreet = person.greet.bind({ name: \"Charlie\" });\nboundGreet(); // Output: Hello, I am Charlie"
      },
      {
        "type": "explanation",
        "text": "When `greetFunc()` is called directly, `this` loses its context (it's not called as a method of `person`). `call()`, `apply()`, and `bind()` can explicitly set the value of `this`. Arrow functions lexically bind `this` from their surrounding scope."
      }
    ],
    "quiz": {
      "snippet": "const myObj = {\n  value: 42,\n  getValue: () => {\n    // Arrow function\n    return this.value;\n  }\n};\nconst anotherObj = { value: 100 };\nconsole.log(myObj.getValue.call(anotherObj));",
      "questionText": "What is logged? (Assuming this code runs in a global scope where `this` is `window` or `undefined` in strict mode)",
      "options": ["42", "100", "undefined", "Error"],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Arrow functions do not have their own `this` binding. They inherit `this` from the surrounding lexical scope. `call()` does not change the `this` context of an arrow function. Thus, `this.value` refers to `window.value` (or `undefined.value` in strict mode), which is likely `undefined`."
    }
  },
  {
    "id": "js-advanced-prototypal-inheritance-004",
    "title": "Prototypal Inheritance",
    "difficulty": "advanced",
    "framework": "JavaScript",
    "frameworkIconText": "JS",
    "tags": ["prototype", "inheritance", "OOP", "__proto__", "Object.create"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "JavaScript uses prototypal inheritance. Objects can inherit properties and methods from other objects via their prototype chain. Every object has a prototype object, and when a property is accessed, JavaScript looks инновационfor it on the object itself, then on its prototype, then on the prototype's prototype, and so on."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "function Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.speak = function() {\n  return `${this.name} makes a sound.`;\n};\n\nfunction Dog(name, breed) {\n  Animal.call(this, name); // Call super constructor\n  this.breed = breed;\n}\n\n// Set up inheritance: Dog's prototype is an Animal instance\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog; // Reset constructor\n\nDog.prototype.bark = function() {\n  return `${this.name} barks!`;\n};\n\nconst myDog = new Dog(\"Rex\", \"German Shepherd\");\nconsole.log(myDog.speak()); // Output: Rex makes a sound.\nconsole.log(myDog.bark());  // Output: Rex barks!"
      },
      {
        "type": "explanation",
        "text": "`Dog.prototype` is set to an object that inherits from `Animal.prototype`. This allows `Dog` instances to access methods like `speak` defined on `Animal.prototype`."
      }
    ],
    "quiz": {
      "snippet": "let animal = { eats: true };\nlet rabbit = Object.create(animal);\nrabbit.jumps = true;\nconsole.log(rabbit.eats && rabbit.jumps);",
      "questionText": "What is the output?",
      "options": ["true", "false", "undefined", "Error"],
      "correctOptionIndex": 0,
      "explanationAfterAnswer": "`rabbit` inherits the `eats` property from `animal` through its prototype chain. Since `rabbit.jumps` is also true, the expression `rabbit.eats && rabbit.jumps` evaluates to true."
    }
  },
  {
    "id": "js-advanced-event-loop-macrotask-microtask-005",
    "title": "Event Loop: Macrotasks & Microtasks",
    "difficulty": "advanced",
    "framework": "JavaScript",
    "frameworkIconText": "JS",
    "tags": ["event loop", "macrotask", "microtask", "setTimeout", "Promise"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "The JavaScript event loop manages execution of code, events, and asynchronous callbacks. It distinguishes between macrotasks (e.g., `setTimeout`, I/O) and microtasks (e.g., `Promise.then`, `queueMicrotask`). All microtasks in the queue are processed after the current macrotask and before the next macrotask."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout (Macrotask)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1 (Microtask)');\n}).then(() => {\n  console.log('Promise 2 (Microtask)');\n});\n\nconsole.log('End');\n\n// Output order:\n// Start\n// End\n// Promise 1 (Microtask)\n// Promise 2 (Microtask)\n// Timeout (Macrotask)"
      },
      {
        "type": "explanation",
        "text": "1. Synchronous code ('Start', 'End') runs. 2. All resolved promise callbacks (microtasks 'Promise 1', 'Promise 2') are executed. 3. Finally, the `setTimeout` callback (macrotask 'Timeout') is executed, even with a 0ms delay."
      }
    ],
    "quiz": {
      "snippet": "setTimeout(() => console.log('A'), 0);\nPromise.resolve().then(() => console.log('B'));\nconsole.log('C');",
      "questionText": "What is the likely order of console logs?",
      "options": ["A, B, C", "C, A, B", "B, C, A", "C, B, A"],
      "correctOptionIndex": 3,
      "explanationAfterAnswer": "Synchronous code 'C' logs first. Promise callbacks (microtasks) like 'B' run after the current macrotask and before the next macrotask (like setTimeout). `setTimeout` 'A' is a macrotask and runs last. So: C, B, A."
    }
  },
  {
    "id": "react-advanced-usecontext-usereducer-001",
    "title": "State Management with `useContext` and `useReducer`",
    "difficulty": "advanced",
    "framework": "React",
    "frameworkIconText": "React",
    "tags": [
      "hooks",
      "useContext",
      "useReducer",
      "state management",
      "global state"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "For more complex state logic or when state needs to be shared across many components at different levels, `useState` can become cumbersome. Combining `useReducer` for state logic and `useContext` for state propagation can provide a powerful pattern for managing global or shared state without prop drilling."
      },
      {
        "type": "code",
        "language": "jsx",
        "code": "import React, { createContext, useContext, useReducer } from 'react';\n\n// 1. Define a reducer function\nconst counterReducer = (state, action) => {\n  switch (action.type) {\n    case 'INCREMENT': return { count: state.count + 1 };\n    case 'DECREMENT': return { count: state.count - 1 };\n    default: throw new Error();\n  }\n};\n\n// 2. Create a context\nconst CounterContext = createContext();\n\n// 3. Create a provider component\nfunction CounterProvider({ children }) {\n  const [state, dispatch] = useReducer(counterReducer, { count: 0 });\n  return (\n    <CounterContext.Provider value={{ state, dispatch }}>\n      {children}\n    </CounterContext.Provider>\n  );\n}\n\n// 4. Consumer component\nfunction DisplayCounter() {\n  const { state } = useContext(CounterContext);\n  return <p>Count: {state.count}</p>;\n}\n\n// 5. Component to dispatch actions\nfunction Controls() {\n  const { dispatch } = useContext(CounterContext);\n  return (\n    <>\n      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>\n      <button onClick={() => dispatch({ type: 'DECREMENT' })}>Decrement</button>\n    </>\n  );\n}\n\n// App structure: <CounterProvider><DisplayCounter /><Controls /></CounterProvider>"
      },
      {
        "type": "explanation",
        "text": "`useReducer` manages complex state updates. `createContext` and `CounterContext.Provider` make the `state` and `dispatch` function available to any descendant component that calls `useContext(CounterContext)`."
      }
    ],
    "quiz": {
      "snippet": "const MyContext = createContext();\nfunction MyProvider({ children }) {\n  const value = \"Shared Value\";\n  return <MyContext.Provider value={value}>{children}</MyContext.Provider>;\n}\nfunction MyConsumer() {\n  const ctxValue = useContext(MyContext);\n  return <p>{ctxValue}</p>;\n}\n// <MyProvider><MyConsumer /></MyProvider>",
      "questionText": "What is the primary benefit of using `useContext` in this scenario?",
      "options": [
        "To optimize component rendering",
        "To avoid passing props down through many intermediate components (prop drilling)",
        "To handle asynchronous operations",
        "To replace the `useState` hook entirely"
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "`useContext` allows components to consume values from a Context Provider without explicitly passing props through every level of the component tree, thus avoiding prop drilling."
    }
  },
  {
    "id": "react-advanced-custom-hooks-002",
    "title": "Creating Custom Hooks",
    "difficulty": "advanced",
    "framework": "React",
    "frameworkIconText": "React",
    "tags": ["hooks", "custom hooks", "reusability", "logic abstraction"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Custom Hooks are a mechanism to reuse stateful logic between components. A custom Hook is a JavaScript function whose name starts with `use` and that can call other Hooks (like `useState`, `useEffect`, etc.)."
      },
      {
        "type": "code",
        "language": "jsx",
        "code": "import { useState, useEffect } from 'react';\n\nfunction useWindowWidth() {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    const handleResize = () => setWidth(window.innerWidth);\n    window.addEventListener('resize', handleResize);\n    // Cleanup listener on unmount\n    return () => window.removeEventListener('resize', handleResize);\n  }, []); // Empty array ensures effect only runs on mount and unmount\n\n  return width;\n}\n\n// Usage in a component:\nfunction MyComponent() {\n  const windowWidth = useWindowWidth();\n  return <p>Window width is: {windowWidth}px</p>;\n}"
      },
      {
        "type": "explanation",
        "text": "The `useWindowWidth` custom Hook encapsulates the logic for tracking window width. Any component can now use this Hook to get the current window width without reimplementing the event listener logic."
      }
    ],
    "quiz": {
      "snippet": "function useToggle(initialValue = false) {\n  const [value, setValue] = useState(initialValue);\n  const toggle = () => setValue(prev => !prev);\n  return [value, toggle];\n}\n// What is a key benefit of creating this `useToggle` custom hook?",
      "questionText": "What is a primary advantage of extracting logic into a custom hook like `useToggle`?",
      "options": [
        "It makes the component render faster.",
        "It allows sharing stateful logic between different components without repeating code.",
        "It automatically memoizes the component.",
        "It replaces the need for `useEffect`."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "Custom hooks are designed to extract and reuse stateful logic. `useToggle` encapsulates the state and the function to toggle it, which can then be used in any number of components."
    }
  },
  {
    "id": "react-advanced-performance-memo-usecallback-003",
    "title": "Performance Optimization with `React.memo` and `useCallback`",
    "difficulty": "advanced",
    "framework": "React",
    "frameworkIconText": "React",
    "tags": [
      "performance",
      "React.memo",
      "useCallback",
      "memoization",
      "optimization"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Unnecessary re-renders can impact performance. `React.memo` is a higher-order component that memoizes your component, preventing re-renders if props haven't changed. `useCallback` memoizes callback functions, preventing child components that depend on them from re-rendering unnecessarily."
      },
      {
        "type": "code",
        "language": "jsx",
        "code": "import React, { useState, useCallback } from 'react';\n\nconst MyButton = React.memo(function MyButton({ onClick, children }) {\n  console.log(`Rendering button: ${children}`);\n  return <button onClick={onClick}>{children}</button>;\n});\n\nfunction App() {\n  const [count1, setCount1] = useState(0);\n  const [count2, setCount2] = useState(0);\n\n  // Without useCallback, incrementCount2 would be a new function on every App render,\n  // causing MyButton 'Increment Count 2' to re-render even if count1 changed.\n  const incrementCount2 = useCallback(() => {\n    setCount2(c => c + 1);\n  }, []); // Empty dependency array means function is memoized and never changes\n\n  return (\n    <div>\n      <p>Count1: {count1}</p>\n      <button onClick={() => setCount1(c => c + 1)}>Increment Count 1</button>\n      <MyButton onClick={incrementCount2}>Increment Count 2</MyButton>\n    </div>\n  );\n}"
      },
      {
        "type": "explanation",
        "text": "`MyButton` is wrapped in `React.memo`. `incrementCount2` is memoized with `useCallback`. When `count1` changes, `App` re-renders. `incrementCount2` remains the same function instance, so `MyButton` (for 'Increment Count 2') does not re-render due to `React.memo`'s prop comparison."
      }
    ],
    "quiz": {
      "snippet": "const HeavyComponent = React.memo(({ data }) => {\n  // ... imagine this is computationally expensive ...\n  return <div>{data.value}</div>;\n});\n// When will React skip re-rendering HeavyComponent?",
      "questionText": "`React.memo` helps optimize a component by:",
      "options": [
        "Always preventing re-renders",
        "Skipping re-renders if its props have not changed (shallow comparison)",
        "Delaying re-renders until the browser is idle",
        "Fetching data more efficiently"
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "`React.memo` performs a shallow comparison of the component's props. If the props haven't changed since the last render, React skips re-rendering the component and reuses the last rendered result."
    }
  },
  {
    "id": "react-advanced-render-props-004",
    "title": "Code Sharing with Render Props Pattern",
    "difficulty": "advanced",
    "framework": "React",
    "frameworkIconText": "React",
    "tags": ["patterns", "render props", "code sharing", "composition"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "The render props pattern is a technique for sharing code between React components using a prop whose value is a function. The component with the render prop calls this function to get JSX to render, allowing the calling component to control what is rendered."
      },
      {
        "type": "code",
        "language": "jsx",
        "code": "class MouseTracker extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { x: 0, y: 0 };\n  }\n\n  handleMouseMove = (event) => {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  };\n\n  render() {\n    return (\n      <div style={{ height: '100vh' }} onMouseMove={this.handleMouseMove}>\n        {/* Call the render prop function with current state */}\n        {this.props.render(this.state)}\n      </div>\n    );\n  }\n}\n\n// Usage:\nfunction App() {\n  return (\n    <MouseTracker render={mouse => (\n      <h1>The mouse position is ({mouse.x}, {mouse.y})</h1>\n    )}/>\n  );\n}"
      },
      {
        "type": "explanation",
        "text": "`MouseTracker` encapsulates the mouse tracking logic. It then calls its `render` prop (which is a function) with the current mouse coordinates. The `App` component provides this `render` function, deciding how to display the mouse coordinates."
      }
    ],
    "quiz": {
      "snippet": "function DataFetcher({ renderData }) {\n  const data = { message: \"Fetched!\" }; // Simulated data\n  return renderData(data);\n}\n// <DataFetcher renderData={data => <p>{data.message}</p>} />",
      "questionText": "What is the primary purpose of the 'render props' pattern?",
      "options": [
        "To manage global application state",
        "To optimize rendering performance of lists",
        "To share reusable behavior or stateful logic by passing a function as a prop that determines what to render",
        "To replace Redux for state management"
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "The render props pattern allows a component to delegate its rendering logic for a part of its UI to another component by passing a function as a prop (often named `render` or `children`). This function then returns the JSX to be rendered."
    }
  },
  {
    "id": "react-advanced-error-boundaries-005",
    "title": "Error Boundaries",
    "difficulty": "advanced",
    "framework": "React",
    "frameworkIconText": "React",
    "tags": [
      "error handling",
      "error boundaries",
      "lifecycle methods",
      "class components"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them."
      },
      {
        "type": "code",
        "language": "jsx",
        "code": "class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service\n    console.error(\"Uncaught error:\", error, errorInfo);\n    this.setState({ errorInfo: errorInfo });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong. Details: {this.state.errorInfo?.componentStack}</h1>;\n    }\n    return this.props.children;\n  }\n}\n\n// Usage:\n// <ErrorBoundary>\n//   <MyFaultyComponent />\n// </ErrorBoundary>"
      },
      {
        "type": "explanation",
        "text": "An error boundary must be a class component and define either (or both) of the static lifecycle method `getDerivedStateFromError()` or the instance method `componentDidCatch()`. `getDerivedStateFromError()` is used to render a fallback UI after an error has been thrown. `componentDidCatch()` is used for side effects like logging errors."
      },
      {
        "type": "important",
        "text": "Error boundaries do NOT catch errors for: Event handlers, Asynchronous code (e.g. `setTimeout` or `requestAnimationFrame` callbacks), Server-side rendering, or Errors thrown in the error boundary itself (rather than its children)."
      }
    ],
    "quiz": {
      "snippet": "// class MyErrorBoundary extends React.Component { ... }\n// <MyErrorBoundary>\n//   <ComponentThatMightCrash />\n// </MyErrorBoundary>\n// If ComponentThatMightCrash throws an error during its render, what happens?",
      "questionText": "What is the primary function of an Error Boundary in React?",
      "options": [
        "To prevent all JavaScript errors in the application",
        "To catch JavaScript errors in its child component tree and display a fallback UI",
        "To automatically fix errors in child components",
        "To handle errors in asynchronous code like `fetch` calls"
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "Error boundaries catch JavaScript errors that occur during rendering, in lifecycle methods, and in constructors of their child component tree, allowing the application to display a fallback UI instead of crashing."
    }
  },
  {
    "id": "nextjs-advanced-isr-001",
    "title": "Incremental Static Regeneration (ISR)",
    "difficulty": "advanced",
    "framework": "Next.js",
    "frameworkIconText": "Next.js",
    "tags": [
      "isr",
      "getStaticProps",
      "revalidate",
      "static generation",
      "performance"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Incremental Static Regeneration (ISR) allows you to update static pages *after* build time without needing to rebuild the entire site. When a request comes in for a page with ISR enabled, Next.js serves the cached static page and, if a revalidation interval has passed, regenerates the page in the background. The next request will then receive the updated page."
      },
      {
        "type": "code",
        "language": "jsx",
        "code": "// pages/products/[id].js\nexport async function getStaticPaths() {\n  // ... (return paths for some initial products)\n  return { paths: [{ params: { id: '1' } }], fallback: 'blocking' };\n  // fallback: 'blocking' will SSR a page if not found, then cache it for SSG.\n  // fallback: true will serve a fallback page klient-side while generating.\n}\n\nexport async function getStaticProps({ params }) {\n  const res = await fetch(`https://api.example.com/products/${params.id}`);\n  const product = await res.json();\n\n  if (!product) {\n    return { notFound: true };\n  }\n\n  return {\n    props: { product },\n    revalidate: 60, // Revalidate this page at most once every 60 seconds\n  };\n}\n\nexport default function ProductPage({ product }) {\n  // ... render product\n  return <div><h1>{product.name}</h1><p>{product.description}</p></div>;\n}"
      },
      {
        "type": "explanation",
        "text": "The `revalidate: 60` option in `getStaticProps` tells Next.js to attempt to re-generate the page if a request comes in after 60 seconds since the last generation. `fallback: 'blocking'` ensures new paths are server-rendered on first visit and then cached statically."
      }
    ],
    "quiz": {
      "snippet": "// In getStaticProps for a page:\nreturn {\n  props: { data },\n  revalidate: 300 // 5 minutes\n};",
      "questionText": "What does the `revalidate` property in the return value of `getStaticProps` enable?",
      "options": [
        "Client-side data re-fetching every 300 seconds",
        "Server-side rendering on every request, caching for 300 seconds",
        "Incremental Static Regeneration, allowing static pages to be updated in the background after build time, at most every 300 seconds",
        "Deleting the static page from cache every 300 seconds"
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "`revalidate` enables Incremental Static Regeneration (ISR). Next.js will serve the stale static page while revalidating (re-generating) the page in the background if the specified time has passed since the last generation. Subsequent requests get the updated page."
    }
  },
  {
    "id": "nextjs-advanced-middleware-002",
    "title": "Edge Middleware for Request Modification",
    "difficulty": "advanced",
    "framework": "Next.js",
    "frameworkIconText": "Next.js",
    "tags": [
      "middleware",
      "edge functions",
      "request lifecycle",
      "redirects",
      "rewrites"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Next.js Middleware allows you to run code *before* a request is completed. It runs on the Edge (close to the user) and can be used for various tasks like authentication, A/B testing, internationalization (i18n) routing, bot detection, or modifying request/response headers."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// middleware.js (at the root or inside `pages` for specific paths)\nimport { NextResponse } from 'next/server';\n\nexport function middleware(request) {\n  const { pathname } = request.nextUrl;\n\n  // Example: Redirect /old-path to /new-path\n  if (pathname.startsWith('/old-path')) {\n    return NextResponse.redirect(new URL('/new-path', request.url));\n  }\n\n  // Example: Add a custom header\n  const response = NextResponse.next(); // Continue to the requested page\n  response.headers.set('x-custom-header', 'my-value');\n  return response;\n}\n\n// Optional: Configure which paths middleware runs on\nexport const config = {\n  matcher: ['/old-path/:path*', '/admin/:path*'],\n};"
      },
      {
        "type": "explanation",
        "text": "Middleware functions receive a `NextRequest` object and can return a `NextResponse` to redirect, rewrite, set headers, or simply pass the request through using `NextResponse.next()`. The `config.matcher` specifies which paths the middleware applies to."
      }
    ],
    "quiz": {
      "snippet": "// middleware.js\nimport { NextResponse } from 'next/server';\nexport function middleware(req) {\n  if (req.nextUrl.pathname === '/secret') {\n    return new Response('Unauthorized', { status: 401 });\n  }\n  return NextResponse.next();\n}",
      "questionText": "What is a primary use case for Next.js Middleware?",
      "options": [
        "Fetching data for static site generation",
        "Running long-running background tasks on the server",
        "Executing code on the Edge before a request is fully processed, for tasks like authentication or redirects",
        "Managing client-side application state"
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Next.js Middleware runs on Edge Functions before a request hits the Next.js server or cache, allowing for URL rewriting, redirection, header modification, authentication checks, and more."
    }
  },
  {
    "id": "nextjs-advanced-app-router-server-components-003",
    "title": "App Router: Server Components vs. Client Components",
    "difficulty": "advanced",
    "framework": "Next.js",
    "frameworkIconText": "Next.js",
    "tags": [
      "app router",
      "server components",
      "client components",
      "rsc",
      "architecture"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "The Next.js App Router (introduced in v13) brings React Server Components (RSC) to the forefront. Components are Server Components by default, meaning they run on the server and can directly access server-side resources (like databases) and perform async operations. Client Components (marked with `'use client'`) run on the client and can use browser APIs and React hooks like `useState` and `useEffect`."
      },
      {
        "type": "code",
        "language": "jsx",
        "code": "// app/dashboard/page.js (Server Component by default)\nasync function getDashboardData() {\n  // const data = await db.query(...); // Can directly access server resources\n  return { revenue: 1000 };\n}\n\nexport default async function DashboardPage() {\n  const data = await getDashboardData();\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      <p>Revenue: ${data.revenue}</p>\n      <InteractiveButton /> {/* Client Component for interactivity */}\n    </div>\n  );\n}\n\n// app/dashboard/InteractiveButton.js\n'use client'; // This marks it as a Client Component\nimport { useState } from 'react';\n\nexport function InteractiveButton() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(c => c + 1)}>Clicks: {count}</button>;\n}"
      },
      {
        "type": "explanation",
        "text": "Server Components reduce the amount of JavaScript sent to the client, improving initial load times. Client Components are opted into when interactivity or browser-specific APIs are needed. Data fetching in Server Components can be done directly using `async/await`."
      }
    ],
    "quiz": {
      "snippet": "// app/user-profile/page.js (default Server Component)\nasync function fetchUser(id) { /* ... fetches user ... */ }\n\nexport default async function UserProfilePage({ params }) {\n  const user = await fetchUser(params.id);\n  return <p>User: {user.name}</p>;\n}\n// When is `fetchUser` typically executed in this Server Component?",
      "questionText": "In the Next.js App Router, when does data fetching (e.g., `await fetchUser()`) inside a default Server Component primarily occur?",
      "options": [
        "On the client-side after the component mounts",
        "On the server, during the request-response lifecycle or at build time",
        "Only when the component is explicitly marked with `'use server'`",
        "Inside a `useEffect` hook on the client"
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "By default, components in the App Router are Server Components. Data fetching within them using `async/await` happens on the server, either during the build process (for static routes) or on-demand per request (for dynamic routes or when revalidating)."
    }
  },
  {
    "id": "nextjs-advanced-route-handlers-004",
    "title": "App Router: Route Handlers (API Endpoints)",
    "difficulty": "advanced",
    "framework": "Next.js",
    "frameworkIconText": "Next.js",
    "tags": ["app router", "route handlers", "api", "request", "response"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "In the Next.js App Router, API endpoints are created using Route Handlers. These are functions exported from a `route.js` (or `route.ts`) file, named after HTTP methods (e.g., `GET`, `POST`, `PUT`, `DELETE`). They use the Web Request and Response APIs."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// app/api/items/route.js\nimport { NextResponse } from 'next/server';\n\nexport async function GET(request) {\n  // const { searchParams } = new URL(request.url);\n  // const id = searchParams.get('id');\n  const items = [{ id: 1, name: 'Item A' }, { id: 2, name: 'Item B' }];\n  return NextResponse.json({ items });\n}\n\nexport async function POST(request) {\n  const body = await request.json(); // Parse JSON body\n  // ... (process body, e.g., save to database)\n  return NextResponse.json({ message: 'Item created', item: body }, { status: 201 });\n}"
      },
      {
        "type": "explanation",
        "text": "A `route.js` file in `app/api/items/` would handle requests to `/api/items`. The exported `GET` function handles GET requests, `POST` handles POST requests, and so on. They receive a `Request` object and should return a `Response` or `NextResponse` object."
      }
    ],
    "quiz": {
      "snippet": "// app/api/greet/route.js\nexport async function GET(request) {\n  const name = request.nextUrl.searchParams.get(\"name\") || \"Guest\";\n  return new Response(`Hello, ${name}!`);\n}\n// A GET request to /api/greet?name=Alice",
      "questionText": "For a GET request to `/api/greet?name=Alice` handled by the above Route Handler, what will be the response body?",
      "options": [
        "Hello, Guest!",
        "Hello, Alice!",
        "{\"message\":\"Hello, Alice!\"}",
        "Error"
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "The `GET` handler retrieves the `name` query parameter from `request.nextUrl.searchParams`. If `name` is 'Alice', the response will be the string 'Hello, Alice!'."
    }
  },
  {
    "id": "nextjs-advanced-dynamic-imports-005",
    "title": "Code Splitting with Dynamic Imports",
    "difficulty": "advanced",
    "framework": "Next.js",
    "frameworkIconText": "Next.js",
    "tags": [
      "performance",
      "code splitting",
      "dynamic import",
      "lazy loading",
      "next/dynamic"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Dynamic imports (`import()`) are a way to implement code-splitting, loading JavaScript chunks only when they are needed. Next.js provides `next/dynamic` for easily importing React components dynamically, which can improve initial page load performance by reducing the main bundle size."
      },
      {
        "type": "code",
        "language": "jsx",
        "code": "import dynamic from 'next/dynamic';\nimport { useState } from 'react';\n\n// Dynamically import a heavy component\nconst HeavyModal = dynamic(() => import('../components/HeavyModal'), {\n  loading: () => <p>Loading modal...</p>,\n  ssr: false // Disable server-side rendering for this component if it's client-only\n});\n\nexport default function HomePage() {\n  const [showModal, setShowModal] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowModal(true)}>Show Heavy Modal</button>\n      {showModal && <HeavyModal onClose={() => setShowModal(false)} />}\n    </div>\n  );\n}"
      },
      {
        "type": "explanation",
        "text": "`next/dynamic` wraps a standard dynamic import. The JavaScript for `HeavyModal` will only be loaded by the client when `showModal` becomes true. The `loading` option provides a fallback UI while the component is loading. `ssr: false` is useful for components that rely on browser APIs."
      }
    ],
    "quiz": {
      "snippet": "import dynamic from 'next/dynamic';\nconst MyChart = dynamic(() => import('../components/MyChartLibrary'), { ssr: false });\n// function Page() { return <MyChart />; }",
      "questionText": "What is a primary benefit of using `next/dynamic` to import a component?",
      "options": [
        "It makes the component's state global by default.",
        "It ensures the component is always server-side rendered for better SEO.",
        "It enables code-splitting, so the component's JavaScript is only loaded when it's needed, improving initial load time.",
        "It automatically translates the component into multiple languages."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "`next/dynamic` facilitates code-splitting by allowing components to be loaded lazily. This means the JavaScript for the dynamically imported component is not included in the initial page bundle and is only fetched by the client when the component is actually rendered."
    }
  },
  {
    "id": "ts-advanced-conditional-types-001",
    "title": "Conditional Types",
    "difficulty": "advanced",
    "framework": "TypeScript",
    "frameworkIconText": "TS",
    "tags": ["conditional types", "generics", "type manipulation", "infer"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Conditional types in TypeScript allow you to choose types based on conditions. They take a form that looks a bit like conditional expressions (condition ? trueType : falseType) in JavaScript."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "type IsString<T> = T extends string ? true : false;\n\ntype A = IsString<string>; // Type A is true\ntype B = IsString<number>; // Type B is false\n\n// Example with 'infer'\ntype ElementType<T> = T extends (infer U)[] ? U : T;\n\ntype C = ElementType<string[]>; // Type C is string\ntype D = ElementType<number>;   // Type D is number\n\ninterface Message {\n  id: number;\n  text: string;\n}\n\ntype MessageIdOrText<T extends Message> = T extends { text: string } ? T[\"text\"] : T[\"id\"];\n\ntype TextPart = MessageIdOrText<{ id: number, text: string }>; // string\ntype IdPart = MessageIdOrText<{ id: number }>;            // number (assuming text is optional or not present)"
      },
      {
        "type": "explanation",
        "text": "`IsString<T>` checks if `T` is assignable to `string`. `ElementType<T>` uses `infer U` to extract the element type if `T` is an array. Conditional types are powerful for creating types that depend on other types."
      }
    ],
    "quiz": {
      "snippet": "type Check<T> = T extends { value: string } ? \"StringType\" : \"OtherType\";\ntype Res1 = Check<{ value: \"hello\" }>;\ntype Res2 = Check<{ value: 123 }>;",
      "questionText": "What are the inferred types for `Res1` and `Res2` respectively?",
      "options": [
        "\"StringType\", \"StringType\"",
        "\"OtherType\", \"StringType\"",
        "\"StringType\", \"OtherType\"",
        "\"OtherType\", \"OtherType\""
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "`Res1` is \"StringType\" because `{ value: \"hello\" }` extends `{ value: string }`. `Res2` is \"OtherType\" because `{ value: 123 }` (where value is a number) does not extend `{ value: string }`."
    }
  },
  {
    "id": "ts-advanced-mapped-types-002",
    "title": "Mapped Types",
    "difficulty": "advanced",
    "framework": "TypeScript",
    "frameworkIconText": "TS",
    "tags": ["mapped types", "generics", "type transformation", "keyof"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Mapped types allow you to create new object types based on the properties of an existing object type. You can transform properties, make them optional, readonly, or change their types."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "interface OriginalInterface {\n  name: string;\n  age: number;\n  isActive: boolean;\n}\n\n// Make all properties optional\ntype PartialOriginal = { [P in keyof OriginalInterface]?: OriginalInterface[P] };\n\n// Make all properties readonly\ntype ReadonlyOriginal = { readonly [P in keyof OriginalInterface]: OriginalInterface[P] };\n\n// Make all properties nullable\ntype NullableOriginal = { [P in keyof OriginalInterface]: OriginalInterface[P] | null };\n\nconst p: PartialOriginal = { name: \"Alice\" }; // age and isActive are optional\nconst r: ReadonlyOriginal = { name: \"Bob\", age: 30, isActive: true };\n// r.age = 31; // Error: Cannot assign to 'age' because it is a read-only property.\nconst n: NullableOriginal = { name: \"Charlie\", age: null, isActive: true };"
      },
      {
        "type": "explanation",
        "text": "`[P in keyof OriginalInterface]` iterates over each property `P` in `OriginalInterface`. `?:` makes the property optional. `readonly` makes it readonly. `OriginalInterface[P]` gets the original type of the property."
      }
    ],
    "quiz": {
      "snippet": "type StringifyProperties<T> = {\n  [K in keyof T]: string;\n};\ninterface MyType { id: number; name: string; }\ntype StringifiedMyType = StringifyProperties<MyType>;\n// let obj: StringifiedMyType = { id: \"1\", name: \"Test\" };",
      "questionText": "What is the type of the `id` property in `StringifiedMyType`?",
      "options": ["number", "string", "number | string", "any"],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "The mapped type `StringifyProperties<T>` transforms every property in `T` to be of type `string`. So, `id`, which was originally a `number` in `MyType`, becomes a `string` in `StringifiedMyType`."
    }
  },
  {
    "id": "ts-advanced-decorators-003",
    "title": "Decorators (Experimental)",
    "difficulty": "advanced",
    "framework": "TypeScript",
    "frameworkIconText": "TS",
    "tags": [
      "decorators",
      "metaprogramming",
      "classes",
      "methods",
      "experimental"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Decorators are a special kind of declaration that can be attached to classes, methods, accessors, properties, or parameters. Decorators use the form `@expression`, where `expression` must evaluate to a function that will be called at runtime with information about the decorated declaration. Note: Decorators are an experimental feature and require `experimentalDecorators` compiler option."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "//tsconfig.json: \"experimentalDecorators\": true, \"emitDecoratorMetadata\": true\n\nfunction loggedMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n  descriptor.value = function(...args: any[]) {\n    console.log(`Calling ${propertyKey} with args: ${JSON.stringify(args)}`);\n    const result = originalMethod.apply(this, args);\n    console.log(`Method ${propertyKey} returned: ${JSON.stringify(result)}`);\n    return result;\n  };\n  return descriptor;\n}\n\nclass Calculator {\n  @loggedMethod\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n\nconst calc = new Calculator();\ncalc.add(5, 3); // Will log calls and return value"
      },
      {
        "type": "explanation",
        "text": "The `@loggedMethod` decorator modifies the `add` method of the `Calculator` class. It wraps the original method to log its arguments and return value. Decorators are a form of metaprogramming."
      }
    ],
    "quiz": {
      "snippet": "@sealed class Greeter {\n  greeting: string;\n  constructor(message: string) { this.greeting = message; }\n  greet() { return \"Hello, \" + this.greeting; }\n}\n// function sealed(constructor: Function) { Object.seal(constructor); Object.seal(constructor.prototype); }\n// What is the primary purpose of a class decorator like `@sealed`?",
      "questionText": "What is a class decorator in TypeScript primarily used for?",
      "options": [
        "To add new instance properties to the class at compile time",
        "To observe, modify, or replace a class definition",
        "To automatically generate unit tests for the class",
        "To restrict the types of arguments passed to the class constructor"
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "A class decorator is applied to the constructor of the class and can be used to observe, modify, or replace the class definition. In the example, `@sealed` could prevent further extensions to the class or its prototype."
    }
  },
  {
    "id": "ts-advanced-mixins-004",
    "title": "Composition with Mixins",
    "difficulty": "advanced",
    "framework": "TypeScript",
    "frameworkIconText": "TS",
    "tags": ["mixins", "composition", "code reuse", "classes", "oop"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Mixins are a way to compose classes by adding reusable functionality. TypeScript supports implementing mixins via class expressions and interface merging. This allows for more flexible code reuse than traditional single inheritance."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// Disposable Mixin\nclass Disposable {\n  isDisposed: boolean = false;\n  dispose() {\n    this.isDisposed = true;\n    console.log('Disposed');\n  }\n}\n\n// Activatable Mixin\nclass Activatable {\n  isActive: boolean = false;\n  activate() { this.isActive = true; console.log('Activated'); }\n  deactivate() { this.isActive = false; console.log('Deactivated'); }\n}\n\nclass SmartObject implements Disposable, Activatable {\n  // Implement stubs for mixin properties/methods for type checking\n  isDisposed: boolean = false;\n  dispose!: () => void;\n  isActive: boolean = false;\n  activate!: () => void;\n  deactivate!: () => void;\n\n  constructor() {\n    setInterval(() => console.log(this.isActive ? \"I'm active!\" : \"I'm inactive.\"), 2000);\n  }\n}\n\n// Helper function to apply mixins\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      Object.defineProperty(derivedCtor.prototype, name, \n        Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null));\n    });\n  });\n}\n\napplyMixins(SmartObject, [Disposable, Activatable]);\n\nconst smartObj = new SmartObject();\nsmartObj.activate();\nsetTimeout(() => smartObj.dispose(), 5000);"
      },
      {
        "type": "explanation",
        "text": "The `SmartObject` class is composed with `Disposable` and `Activatable` behaviors using the `applyMixins` helper. This allows `SmartObject` instances to have methods like `dispose()` and `activate()`."
      }
    ],
    "quiz": {
      "snippet": "class A { methodA() { return 'A'; } }\nclass B { methodB() { return 'B'; } }\nclass C implements A, B { /* ... stubs ... */ }\n// applyMixins(C, [A, B]);\n// const c_instance = new C();",
      "questionText": "What is a primary benefit of using the mixin pattern in TypeScript/JavaScript?",
      "options": [
        "Enforcing strict single inheritance for all classes",
        "Achieving code reuse by composing multiple smaller pieces of functionality into a class",
        "Simplifying asynchronous operations",
        "Replacing the need for interfaces"
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "Mixins allow for code reuse by enabling a class to adopt methods and properties from multiple other 'mixin' classes, effectively composing behaviors rather than relying solely on single inheritance."
    }
  },
  {
    "id": "ts-advanced-declaration-merging-005",
    "title": "Declaration Merging (Interfaces & Namespaces)",
    "difficulty": "advanced",
    "framework": "TypeScript",
    "frameworkIconText": "TS",
    "tags": [
      "declaration merging",
      "interfaces",
      "namespaces",
      "module augmentation"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Declaration merging is a unique feature in TypeScript where the compiler merges two or more separate declarations declared with the same name into a single definition. This is most notably done with interfaces and namespaces."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// Interface merging\ninterface Box {\n  height: number;\n  width: number;\n}\ninterface Box {\n  scale: number;\n  // height: string; // Error: Subsequent property declarations must have the same type.\n}\nlet box: Box = { height: 5, width: 6, scale: 10 };\n\n// Namespace merging (can merge with functions, classes, enums too)\nnamespace Animals {\n  export class Zebra { }\n}\nnamespace Animals {\n  // export interface Legged { numberOfLegs: number; }\n  export class Dog { }\n}\n// const zebra = new Animals.Zebra();\n// const dog = new Animals.Dog();"
      },
      {
        "type": "explanation",
        "text": "Multiple interface declarations with the same name are merged into a single interface with all the properties from each declaration. Namespaces with the same name also merge, combining their exported members. This is often used for extending existing types or organizing code."
      }
    ],
    "quiz": {
      "snippet": "interface User {\n  name: string;\n}\ninterface User {\n  age: number;\n}\n// let myUser: User = { name: \"Sam\", age: 30 };",
      "questionText": "If two `User` interfaces are declared as shown, what properties must an object of type `User` have?",
      "options": [
        "Either `name` or `age`",
        "Only `name` if the first declaration is used, or only `age` if the second is used",
        "Both `name` (string) and `age` (number)",
        "This will cause a compile-time error due to duplicate interface names"
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "TypeScript merges interface declarations with the same name. An object of type `User` must have all properties from all merged `User` interface declarations, so it needs both `name` (string) and `age` (number)."
    }
  },
  {
    "id": "vue-advanced-render-functions-001",
    "title": "Programmatic Rendering with Render Functions",
    "difficulty": "advanced",
    "framework": "Vue.js",
    "frameworkIconText": "Vue",
    "tags": [
      "render functions",
      "h function",
      "programmatic rendering",
      "jsx in vue"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "While templates are great for most cases, sometimes you need the full programmatic power of JavaScript to create your UI. Render functions (using `h` from Vue, or JSX with proper setup) allow you to do this. They are closer to the metal and can be more performant or flexible for certain dynamic UIs or higher-order components."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Using Vue's h() function\nimport { h } from 'vue';\n\nconst DynamicHeading = {\n  props: {\n    level: { type: Number, required: true, validator: (val) => [1,2,3,4,5,6].includes(val) }\n  },\n  render() {\n    // h(tag, propsAndAttrs, children)\n    return h(\n      `h${this.level}`,\n      { class: 'dynamic-heading' },\n      this.$slots.default ? this.$slots.default() : 'Default Heading'\n    );\n  }\n};\n\n// App.vue (example usage, assuming DynamicHeading is registered)\n// <dynamic-heading :level=\"1\">My Main Title</dynamic-heading>\n// <dynamic-heading :level=\"3\">A Subtitle</dynamic-heading>"
      },
      {
        "type": "explanation",
        "text": "The `render` function in `DynamicHeading` uses Vue's `h()` (hyperscript) function to programmatically create a heading element (`h1` to `h6`) based on the `level` prop. It also accesses slot content using `this.$slots.default()`."
      },
      {
        "type": "tip",
        "text": "With appropriate Babel or TypeScript setup, you can also use JSX directly in Vue render functions, which some developers find more intuitive if coming from React."
      }
    ],
    "quiz": {
      "snippet": "import { h } from 'vue';\nconst SimpleParagraph = {\n  render() {\n    return h('p', null, 'Hello from render function');\n  }\n};",
      "questionText": "What does the `h` function in Vue (often imported from 'vue') primarily do in a render function?",
      "options": [
        "Handle HTTP requests",
        "Create virtual DOM nodes (VNodes)",
        "Manage component state",
        "Define CSS styles"
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "The `h()` function (short for hyperscript) is used in render functions to create Virtual DOM nodes (VNodes), which Vue then uses to efficiently update the actual DOM."
    }
  },
  {
    "id": "vue-advanced-composition-api-logic-reuse-002",
    "title": "Advanced Logic Reuse with Composition API",
    "difficulty": "advanced",
    "framework": "Vue.js",
    "frameworkIconText": "Vue",
    "tags": [
      "composition api",
      "composables",
      "logic reuse",
      "reactivity",
      "setup function"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "The Composition API (introduced in Vue 3) provides a flexible way to organize and reuse component logic. Composable functions (or 'composables') are functions that encapsulate reactive state and logic, which can then be easily imported and used across multiple components."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// composables/useMousePosition.js\nimport { ref, onMounted, onUnmounted } from 'vue';\n\nexport function useMousePosition() {\n  const x = ref(0);\n  const y = ref(0);\n\n  function update(event) {\n    x.value = event.pageX;\n    y.value = event.pageY;\n  }\n\n  onMounted(() => window.addEventListener('mousemove', update));\n  onUnmounted(() => window.removeEventListener('mousemove', update));\n\n  return { x, y }; // Expose reactive state\n}\n\n// MyComponent.vue (using the composable)\n// <template>\n//   <div>Mouse position: X={{ x }}, Y={{ y }}</div>\n// </template>\n// <script setup>\n// import { useMousePosition } from './composables/useMousePosition';\n// const { x, y } = useMousePosition();\n// </script>"
      },
      {
        "type": "explanation",
        "text": "`useMousePosition` is a composable function that tracks the mouse's x and y coordinates. It uses `ref` for reactive data and `onMounted`/`onUnmounted` for lifecycle management of event listeners. Any component can import and use it to get reactive mouse coordinates."
      }
    ],
    "quiz": {
      "snippet": "// composables/useCounter.js\n// import { ref } from 'vue';\n// export function useCounter(initialValue = 0) {\n//   const count = ref(initialValue);\n//   const increment = () => count.value++;\n//   return { count, increment };\n// }\n// ComponentA: const { count, increment } = useCounter();\n// ComponentB: const { count: countB, increment: incrementB } = useCounter(10);",
      "questionText": "What is a key advantage of using composable functions (like `useCounter`) with the Composition API?",
      "options": [
        "They automatically make components globally available.",
        "They provide a way to organize and reuse stateful logic across different components without mixins or inheritance.",
        "They replace the need for Vuex or Pinia for all state management.",
        "They are only for creating UI elements."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "Composable functions in Vue's Composition API are primarily designed to encapsulate and reuse stateful logic. Each component instance using the composable gets its own instance of the state defined within it, promoting better organization and testability than traditional mixins."
    }
  },
  {
    "id": "vue-advanced-custom-directives-003",
    "title": "Creating Custom Directives",
    "difficulty": "advanced",
    "framework": "Vue.js",
    "frameworkIconText": "Vue",
    "tags": [
      "custom directives",
      "dom manipulation",
      "reusability",
      "v-prefix"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "In addition to the default directives (like `v-if`, `v-for`), Vue allows you to register your own custom directives. This is useful when you need low-level DOM access on plain elements, often for integrating third-party libraries or implementing reusable DOM manipulations."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<div id=\"app\">\n  <input v-focus type=\"text\" placeholder=\"I should have focus on load\">\n  <p v-highlight:yellow.bold=\"'This text will be highlighted'\"></p>\n</div>\n\n<script>\n  const app = Vue.createApp({});\n\n  // Global custom directive v-focus\n  app.directive('focus', {\n    mounted(el) {\n      // el is the element the directive is bound to\n      el.focus();\n    }\n  });\n\n  // Global custom directive v-highlight with arguments and modifiers\n  app.directive('highlight', {\n    mounted(el, binding) {\n      // binding.value: the value passed to the directive ('This text...')\n      // binding.arg: the argument passed (e.g., 'yellow')\n      // binding.modifiers: an object of modifiers (e.g., { bold: true })\n      el.textContent = binding.value;\n      el.style.backgroundColor = binding.arg || 'transparent';\n      if (binding.modifiers.bold) {\n        el.style.fontWeight = 'bold';\n      }\n    }\n  });\n\n  app.mount('#app');\n</script>"
      },
      {
        "type": "explanation",
        "text": "The `v-focus` directive automatically focuses the input element when it's mounted. The `v-highlight` directive takes a value, an argument (for color), and a modifier (`.bold`) to style the element's text and background."
      }
    ],
    "quiz": {
      "snippet": "// app.directive('my-directive', {\n//   mounted(el, binding) { /* ... */ },\n//   updated(el, binding) { /* ... */ }\n// });\n// When would you typically use a custom directive in Vue?",
      "questionText": "What is a common scenario for creating a custom directive in Vue?",
      "options": [
        "For managing complex application state",
        "For reusing component UI structure",
        "When you need to perform direct, low-level DOM manipulations on an element in a reusable way",
        "For defining computed properties"
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Custom directives are primarily for cases where you need to encapsulate reusable logic that involves direct manipulation of the DOM element the directive is bound to."
    }
  },
  {
    "id": "vue-advanced-ssr-hydration-004",
    "title": "Understanding SSR and Hydration (Conceptual)",
    "difficulty": "advanced",
    "framework": "Vue.js",
    "frameworkIconText": "Vue",
    "tags": ["ssr", "server-side rendering", "hydration", "performance", "seo"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Server-Side Rendering (SSR) means rendering Vue components on the server into HTML strings, sending them directly to the browser. Hydration is the client-side process where Vue takes over the static HTML sent by the server and makes it dynamic and interactive by attaching event listeners and reactive data."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Simplified conceptual server-side rendering (e.g., with Nuxt.js or a custom setup)\n// server.js (Node.js example)\n// import { createApp } from 'vue';\n// import { renderToString } from 'vue/server-renderer';\n// const app = createApp({ template: '<div>{{ message }}</div>', data: () => ({ message: 'Hello SSR' }) });\n// renderToString(app).then(html => { /* send html to client */ });\n\n// Client-side hydration (main.js)\n// import { createApp } from 'vue';\n// const appData = { message: 'Hello SSR' }; // Initial data might come from server\n// const app = createApp({ template: '<div>{{ message }}</div>', data: () => appData });\n// app.mount('#app', true); // The 'true' often indicates hydration mode (in older Vue versions or specific SSR setups)"
      },
      {
        "type": "explanation",
        "text": "SSR improves perceived performance (faster TTI - Time To Interactive) and SEO. During hydration, Vue ensures the client-side virtual DOM matches the server-rendered DOM and then makes the application interactive. Frameworks like Nuxt.js abstract much of this complexity."
      },
      {
        "type": "important",
        "text": "Care must be taken to ensure that the initial client-side render matches the server-rendered output to avoid hydration mismatches. Lifecycle hooks like `onMounted` (Composition API) or `mounted` (Options API) only run on the client."
      }
    ],
    "quiz": {
      "snippet": "// A Vue app is server-rendered. The client receives HTML and then Vue 'hydrates' it.\n// What does 'hydration' primarily involve?",
      "questionText": "In the context of Vue SSR, what is 'hydration'?",
      "options": [
        "Fetching all application data from the server again on the client",
        "The process of Vue taking control of the server-rendered static HTML and making it interactive on the client",
        "Re-building the entire DOM tree from scratch on the client",
        "Compressing the HTML sent from the server"
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "Hydration is the client-side process where Vue attaches event listeners and makes the server-rendered static HTML interactive, effectively 'breathing life' into it without re-creating all DOM nodes from scratch if the structure matches."
    }
  },
  {
    "id": "vue-advanced-teleport-005",
    "title": "Moving Content with `<Teleport>`",
    "difficulty": "advanced",
    "framework": "Vue.js",
    "frameworkIconText": "Vue",
    "tags": ["teleport", "dom structure", "modals", "popups", "ui"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "`<Teleport>` is a built-in component that allows you to render a part of a component's template in a different DOM location, outside of that component's own DOM hierarchy. This is particularly useful for UI elements like modals, notifications, or tooltips that need to break out of their parent component's styling or stacking context."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<div id=\"app\">\n  <button @click=\"showModal = true\">Show Modal</button>\n  \n  <teleport to=\"body\"> <!-- Teleport content to the end of <body> -->\n    <div v-if=\"showModal\" class=\"modal-overlay\">\n      <div class=\"modal-content\">\n        <p>This is a teleported modal!</p>\n        <button @click=\"showModal = false\">Close</button>\n      </div>\n    </div>\n  </teleport>\n</div>\n\n<script>\n  Vue.createApp({\n    data() {\n      return { showModal: false };\n    }\n  }).mount('#app');\n</script>\n\n<style>\n/* Basic modal styling */\n.modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; }\n.modal-content { background: white; padding: 20px; border-radius: 5px; }\n</style>"
      },
      {
        "type": "explanation",
        "text": "The content inside `<teleport to=\"body\">` will be rendered as a direct child of the `<body>` tag, even though the `<teleport>` component itself is defined within the main Vue app structure. The `to` prop accepts a CSS selector or a DOM element."
      }
    ],
    "quiz": {
      "snippet": "<teleport to=\"#notifications-container\">\n  <div class=\"notification\">New message!</div>\n</teleport>\n// Where will the notification div be rendered in the final DOM?",
      "questionText": "What is the primary purpose of Vue's `<Teleport>` component?",
      "options": [
        "To create reusable animation transitions",
        "To fetch data from a remote API",
        "To render a part of a component's template into a different DOM location outside its parent hierarchy",
        "To manage global application state"
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "`<Teleport>` allows you to move a piece of your component's template to a different location in the DOM, which is useful for full-screen modals, notifications, or any element that needs to escape its parent's CSS context or stacking order."
    }
  },
  {
    "id": "angular-advanced-rxjs-operators-001",
    "title": "Advanced RxJS Operators in Services/Components",
    "difficulty": "advanced",
    "framework": "Angular",
    "frameworkIconText": "Angular",
    "tags": [
      "rxjs",
      "observables",
      "operators",
      "switchMap",
      "debounceTime",
      "state management"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "RxJS is integral to Angular, especially for handling asynchronous operations and state. Advanced operators like `switchMap`, `debounceTime`, `distinctUntilChanged`, `combineLatest`, and error handling operators (`catchError`, `retry`) are crucial for building robust and efficient applications."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// search.service.ts\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, Subject, of } from 'rxjs';\nimport { map, debounceTime, distinctUntilChanged, switchMap, catchError } from 'rxjs/operators';\n\ninterface SearchResult { id: string; name: string; }\n\n@Injectable({ providedIn: 'root' })\nexport class SearchService {\n  private apiUrl = 'https://api.example.com/search?q=';\n\n  constructor(private http: HttpClient) {}\n\n  // searchTerm$ is a Subject that components can push search terms into\n  performSearch(searchTerm$: Observable<string>): Observable<SearchResult[]> {\n    return searchTerm$.pipe(\n      debounceTime(300), // Wait for 300ms pause in events\n      distinctUntilChanged(), // Only if the term has changed\n      switchMap(term => { // Switch to new search observable, cancel previous\n        if (!term.trim()) return of([]); // Return empty array if term is empty\n        return this.http.get<SearchResult[]>(`${this.apiUrl}${term}`).pipe(\n          catchError(error => {\n            console.error('Search API error:', error);\n            return of([]); // Return empty array on error\n          })\n        );\n      })\n    );\n  }\n}\n\n// Component using this service would create a Subject, pass it to performSearch,\n// and subscribe to the returned Observable or use the async pipe."
      },
      {
        "type": "explanation",
        "text": "This search service uses `debounceTime` to avoid excessive API calls while typing, `distinctUntilChanged` to only search if the term changes, and `switchMap` to cancel previous pending searches and switch to the new one. `catchError` handles potential HTTP errors gracefully."
      }
    ],
    "quiz": {
      "snippet": "searchTerm$.pipe(\n  debounceTime(500),\n  switchMap(term => this.api.search(term))\n);",
      "questionText": "What is the primary benefit of using `switchMap` in this RxJS pipe when handling user search input?",
      "options": [
        "It combines results from all previous search terms.",
        "It ensures only the results from the latest search term are emitted, cancelling previous pending requests.",
        "It delays the execution of the search by 500ms.",
        "It transforms each search term into a boolean."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "`switchMap` is ideal for scenarios like type-ahead search because it unsubscribes from the previous inner Observable (the API request) when a new value arrives from the outer Observable (the search term), thus cancelling the previous request and only processing the latest one."
    }
  },
  {
    "id": "angular-advanced-change-detection-002",
    "title": "Change Detection Strategies (`OnPush`)",
    "difficulty": "advanced",
    "framework": "Angular",
    "frameworkIconText": "Angular",
    "tags": [
      "change detection",
      "OnPush",
      "performance",
      "immutability",
      "optimization"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Angular's change detection mechanism checks for changes in component data and re-renders the view. By default (`ChangeDetectionStrategy.Default`), Angular checks every component in the tree. The `OnPush` strategy optimizes this by only running change detection for a component when its `@Input()` properties change reference, or an event originates from it or one of its children, or it's explicitly marked for check (e.g., via `AsyncPipe` or `ChangeDetectorRef.markForCheck()`)."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// user-card.component.ts\nimport { Component, Input, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';\n\ninterface User { id: number; name: string; }\n\n@Component({\n  selector: 'app-user-card',\n  template: `<div>User: {{ user.name }} (ID: {{ user.id }})</div>`,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserCardComponent {\n  @Input() user!: User;\n\n  constructor(private cd: ChangeDetectorRef) {}\n\n  // Example of manually triggering change detection if needed for an external update\n  // refresh() { this.cd.markForCheck(); }\n}\n\n// parent.component.ts\n// ...\n// this.currentUser = { id: 1, name: \"Alice\" }; // Initial assignment\n// // To trigger OnPush update, you MUST pass a new object reference:\n// updateUser() {\n//   this.currentUser = { ...this.currentUser, name: \"Alicia\" }; // New object reference\n//   // NOT: this.currentUser.name = \"Alicia\"; (this won't trigger OnPush CD)\n// }"
      },
      {
        "type": "explanation",
        "text": "Using `ChangeDetectionStrategy.OnPush` can significantly improve performance in large applications by reducing the number of components Angular needs to check. It works best with immutable data structures, where new object references are created for changes."
      }
    ],
    "quiz": {
      "snippet": "@Component({\n  selector: 'app-my-onpush',\n  template: '{{ data.value }}',\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class MyOnPushComponent {\n  @Input() data: { value: string };\n}",
      "questionText": "If `MyOnPushComponent` uses `ChangeDetectionStrategy.OnPush`, which of the following will typically NOT trigger its re-evaluation by default?",
      "options": [
        "A new object reference is passed to its `@Input() data` property.",
        "An event (like a click) originates from within `MyOnPushComponent`'s template.",
        "A property of the existing `data` object is mutated directly (e.g., `this.data.value = 'new';`) by the parent without changing the `data` object reference.",
        "The `async` pipe in its template receives a new value from an Observable."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "With `ChangeDetectionStrategy.OnPush`, Angular only checks the component if its input property references change. Mutating a property of an existing input object directly (e.g., `data.value = 'new'`) without changing the `data` object itself will not trigger change detection for that component by default."
    }
  },
  {
    "id": "angular-advanced-content-projection-ng-content-003",
    "title": "Advanced Content Projection with `ng-content` and `select`",
    "difficulty": "advanced",
    "framework": "Angular",
    "frameworkIconText": "Angular",
    "tags": [
      "content projection",
      "ng-content",
      "slots",
      "reusable components"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "`<ng-content>` is Angular's mechanism for content projection (similar to slots in Web Components or Vue). It allows you to create components that can host content provided by the parent component. The `select` attribute on `<ng-content>` enables more specific projection based on CSS selectors."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<!-- card.component.html -->\n<div class=\"card\">\n  <div class=\"card-header\">\n    <ng-content select=\"[card-title]\"></ng-content> <!-- Project elements with 'card-title' attribute -->\n    <ng-content select=\".card-subtitle\"></ng-content> <!-- Project elements with 'card-subtitle' class -->\n  </div>\n  <div class=\"card-body\">\n    <ng-content></ng-content> <!-- Default slot for any other content -->\n  </div>\n  <div class=\"card-footer\">\n    <ng-content select=\"footer\"></ng-content> <!-- Project <footer> elements -->\n  </div>\n</div>\n\n<!-- app.component.html (usage) -->\n<!-- \n<app-card>\n  <h2 card-title>My Card Title</h2>\n  <p class=\"card-subtitle\">A catchy subtitle.</p>\n  <p>This is the main content of the card, it goes into the default slot.</p>\n  <footer>Card Footer Content</footer>\n</app-card>\n-->"
      },
      {
        "type": "explanation",
        "text": "The `app-card` component uses multiple `<ng-content>` tags with `select` attributes to project specific parts of the parent's content into designated areas (header, body, footer). Content that doesn't match any `select` criteria goes into the `<ng-content>` without a `select` attribute (the default slot)."
      }
    ],
    "quiz": {
      "snippet": "<!-- child.component.html -->\n<div>\n  <ng-content select=\".header\"></ng-content>\n  <ng-content></ng-content> <!-- Default -->\n</div>\n\n<!-- parent.component.html -->\n<app-child>\n  <h1 class=\"header\">Title</h1>\n  <p>Main text</p>\n  <span>Other text</span>\n</app-child>",
      "questionText": "In the parent's usage of `app-child`, where will `<p>Main text</p>` and `<span>Other text</span>` be projected?",
      "options": [
        "Both in the first `ng-content` (header slot)",
        "Both in the second `ng-content` (default slot)",
        "`Main text` in header, `Other text` in default",
        "Neither will be projected"
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "The `<h1>` with class `header` matches `select=\".header\"` and goes into the first `ng-content`. The `<p>Main text</p>` and `<span>Other text</span>` do not match any specific selector, so they are projected into the default `<ng-content>` (the one without a `select` attribute)."
    }
  },
  {
    "id": "angular-advanced-reactive-forms-custom-validator-004",
    "title": "Reactive Forms: Custom Validators and Async Validators",
    "difficulty": "advanced",
    "framework": "Angular",
    "frameworkIconText": "Angular",
    "tags": [
      "forms",
      "reactive forms",
      "FormBuilder",
      "Validators",
      "custom validators",
      "async validators"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Reactive forms provide a model-driven approach to handling form inputs. Beyond built-in validators, you can create custom synchronous and asynchronous validators to implement complex validation logic."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// registration.component.ts\nimport { Component, OnInit } from '@angular/core';\nimport { FormBuilder, FormGroup, Validators, AbstractControl, ValidationErrors, AsyncValidatorFn } from '@angular/forms';\nimport { Observable, of } from 'rxjs';\nimport { map, delay } from 'rxjs/operators';\n\n// Custom synchronous validator\nfunction forbiddenNameValidator(forbiddenName: RegExp): (control: AbstractControl) => ValidationErrors | null {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const forbidden = forbiddenName.test(control.value);\n    return forbidden ? { forbiddenName: { value: control.value } } : null;\n  };\n}\n\n// Custom asynchronous validator (simulated)\nfunction uniqueUsernameValidator(): AsyncValidatorFn {\n  return (control: AbstractControl): Observable<ValidationErrors | null> => {\n    // Simulate API call to check if username is unique\n    return of(control.value === 'takenUser').pipe(\n      delay(1000),\n      map(isTaken => (isTaken ? { usernameTaken: true } : null))\n    );\n  };\n}\n\n@Component({...})\nexport class RegistrationComponent implements OnInit {\n  registrationForm!: FormGroup;\n  constructor(private fb: FormBuilder) {}\n\n  ngOnInit() {\n    this.registrationForm = this.fb.group({\n      username: ['', \n        [Validators.required, Validators.minLength(3), forbiddenNameValidator(/admin/i)],\n        [uniqueUsernameValidator()]\n      ],\n      email: ['', [Validators.required, Validators.email]]\n    });\n  }\n  // In template: <input formControlName=\"username\"> \n  // {{ registrationForm.get('username')?.errors | json }}\n}"
      },
      {
        "type": "explanation",
        "text": "`forbiddenNameValidator` is a custom synchronous validator factory. `uniqueUsernameValidator` is a custom asynchronous validator factory that returns an Observable. They are added to the `FormControl`'s validators array."
      }
    ],
    "quiz": {
      "snippet": "username: new FormControl('', {\n  validators: [Validators.required],\n  asyncValidators: [this.userService.checkUsernameUnique.bind(this.userService)],\n  updateOn: 'blur'\n})",
      "questionText": "What is a key difference between synchronous and asynchronous validators in Angular Reactive Forms?",
      "options": [
        "Synchronous validators run on 'submit', async on 'change'.",
        "Synchronous validators return `ValidationErrors | null`, while async validators return `Observable<ValidationErrors | null>` or `Promise<ValidationErrors | null>`.",
        "Only async validators can access external services.",
        "Synchronous validators cannot be custom-made."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "Synchronous validators directly return an error object or null. Asynchronous validators (e.g., for checking if a username is unique against a server) return a Promise or an Observable that eventually emits an error object or null."
    }
  },
  {
    "id": "angular-advanced-ngrx-store-concept-005",
    "title": "State Management with NgRx (Conceptual Overview)",
    "difficulty": "advanced",
    "framework": "Angular",
    "frameworkIconText": "Angular",
    "tags": [
      "ngrx",
      "state management",
      "redux pattern",
      "store",
      "actions",
      "reducers",
      "effects",
      "selectors"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "NgRx is a framework for building reactive applications in Angular, inspired by Redux. It provides state management using a single, immutable state tree (Store), Actions to describe state changes, Reducers to handle state transitions, Effects for side effects (like API calls), and Selectors to efficiently query state."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// Core NgRx Concepts (Simplified - actual implementation involves more boilerplate)\n\n// 1. State Interface\n// export interface AppState { counter: number; }\n\n// 2. Actions (describe what happened)\n// export const increment = createAction('[Counter] Increment');\n// export const loadData = createAction('[Data] Load Data');\n// export const loadDataSuccess = createAction('[Data API] Load Data Success', props<{ data: any[] }>());\n\n// 3. Reducers (handle state changes based on actions - pure functions)\n// export const counterReducer = createReducer(\n//   initialState, // { counter: 0 }\n//   on(increment, state => ({ ...state, counter: state.counter + 1 }))\n// );\n\n// 4. Effects (handle side effects like API calls)\n// @Injectable()\n// export class DataEffects {\n//   loadData$ = createEffect(() => this.actions$.pipe(\n//     ofType(loadData),\n//     exhaustMap(() => this.apiService.getData().pipe(\n//       map(data => loadDataSuccess({ data })),\n//       catchError(() => of({ type: '[Data API] Load Data Failure' }))\n//     ))\n//   ));\n//   constructor(private actions$: Actions, private apiService: ApiService) {}\n// }\n\n// 5. Selectors (query parts of the state)\n// export const selectCounter = (state: AppState) => state.counter;\n\n// In Component: \n// count$: Observable<number>;\n// constructor(private store: Store<AppState>) {\n//   this.count$ = this.store.pipe(select(selectCounter));\n// }\n// dispatchIncrement() { this.store.dispatch(increment()); }"
      },
      {
        "type": "explanation",
        "text": "The flow is typically: Component dispatches an Action -> (Optional) Effect listens for Action, performs side effect, dispatches new Action(s) -> Reducer receives Action, computes new state -> Store updates -> Component (subscribed via Selector) re-renders with new state. This provides a predictable, unidirectional data flow."
      }
    ],
    "quiz": {
      "snippet": "// An NgRx Reducer function\n// on(someAction, (state, actionPayload) => { /* return new state */ })",
      "questionText": "What is the primary responsibility of a Reducer function in NgRx?",
      "options": [
        "To perform asynchronous API calls",
        "To define the component's template",
        "To take the current state and an action, and return a new state (it must be a pure function)",
        "To directly manipulate the DOM"
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Reducers in NgRx (and Redux) are pure functions responsible for calculating the next state based on the current state and a dispatched action. They must not have side effects."
    }
  },
  {
    "id": "nodejs-advanced-child-process-exec-001",
    "title": "Child Processes: `exec` and `spawn`",
    "difficulty": "advanced",
    "framework": "Node.js",
    "frameworkIconText": "Node",
    "tags": [
      "child process",
      "exec",
      "spawn",
      "system commands",
      "concurrency"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Node.js can create child processes to execute external system commands or run other scripts. The `child_process` module provides functions like `exec` (for simple commands, buffers output) and `spawn` (for longer-running processes, streams I/O)."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "const { exec, spawn } = require('child_process');\n\n// Using exec (good for short commands, output is buffered)\nexec('ls -lh /usr', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error.message}`);\n    return;\n  }\n  if (stderr) {\n    console.error(`stderr: ${stderr}`);\n    // return; // Stderr doesn't always mean an error in execution\n  }\n  console.log(`stdout from exec:\\n${stdout.substring(0, 100)}...`); // Log first 100 chars\n});\n\n// Using spawn (better for long-running processes or large I/O)\nconst findProcess = spawn('find', ['.', '-type', 'f']);\n\nfindProcess.stdout.on('data', (data) => {\n  // console.log(`spawn stdout chunk: ${data.toString().substring(0,50)}...`);\n});\n\nfindProcess.stderr.on('data', (data) => {\n  console.error(`spawn stderr: ${data}`);\n});\n\nfindProcess.on('close', (code) => {\n  console.log(`spawn child process exited with code ${code}`);\n});\n\nfindProcess.on('error', (err) => {\n  console.error('Failed to start subprocess for spawn.', err);\n});"
      },
      {
        "type": "explanation",
        "text": "`exec` buffers the command's output and passes it to a callback. `spawn` returns a `ChildProcess` object and streams `stdout` and `stderr`, making it suitable for large outputs or interactive commands. Error handling is crucial for both."
      }
    ],
    "quiz": {
      "snippet": "// const { spawn } = require('child_process');\n// const myCommand = spawn('git', ['status']);\n// myCommand.stdout.on('data', (chunk) => { /* process chunk */ });",
      "questionText": "What is a key difference between `child_process.exec()` and `child_process.spawn()`?",
      "options": [
        "`exec` is synchronous, `spawn` is asynchronous.",
        "`spawn` can only run shell scripts, `exec` can run any command.",
        "`exec` buffers the entire output before calling the callback, while `spawn` streams I/O, making it better for large outputs or long-running processes.",
        "`spawn` is deprecated in favor of `execFile`."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "`exec()` buffers the command's output (max buffer size applies), which can be an issue for commands producing large output. `spawn()` streams the I/O, making it more memory-efficient and suitable for continuous output or interactive processes."
    }
  },
  {
    "id": "nodejs-advanced-cluster-module-002",
    "title": "Scaling with the `cluster` Module",
    "difficulty": "advanced",
    "framework": "Node.js",
    "frameworkIconText": "Node",
    "tags": ["cluster", "scaling", "multi-core", "performance", "workers"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Node.js is single-threaded. To take advantage of multi-core systems, you can use the `cluster` module. It allows you to create child processes (workers) that share server ports, distributing the load across CPU cores."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "const cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster || cluster.isPrimary) { // isPrimary is the newer property\n  console.log(`Master ${process.pid} is running`);\n\n  // Fork workers.\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died. Forking another...`);\n    cluster.fork(); // Replace the dead worker\n  });\n} else {\n  // Workers can share any TCP connection\n  // In this case, it is an HTTP server\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end(`Hello from worker ${process.pid}\\n`);\n    console.log(`Worker ${process.pid} handled request`);\n  }).listen(8000);\n\n  console.log(`Worker ${process.pid} started`);\n}"
      },
      {
        "type": "explanation",
        "text": "The master process forks a worker process for each CPU core. Each worker runs its own instance of the HTTP server, but they all listen on the same port (8000). The OS handles load balancing between workers. If a worker dies, the master can fork a new one."
      }
    ],
    "quiz": {
      "snippet": "// const cluster = require('cluster');\n// const numCPUs = require('os').cpus().length;\n// if (cluster.isMaster) { for (let i = 0; i < numCPUs; i++) { cluster.fork(); } } else { /* run server */ }",
      "questionText": "What is the primary purpose of using the `cluster` module in a Node.js application?",
      "options": [
        "To run multiple different Node.js applications on the same server.",
        "To enable Node.js applications to take advantage of multi-core systems by creating multiple worker processes.",
        "To create a distributed database cluster.",
        "To manage inter-process communication using shared memory."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "The `cluster` module allows a Node.js application to create child processes (workers) that can share the same server port. This enables the application to distribute incoming connections across multiple CPU cores, improving performance and scalability on multi-core systems."
    }
  },
  {
    "id": "nodejs-advanced-transform-streams-003",
    "title": "Custom Transform Streams",
    "difficulty": "advanced",
    "framework": "Node.js",
    "frameworkIconText": "Node",
    "tags": ["streams", "Transform stream", "data processing", "pipe"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Transform streams are a type of Duplex stream where the output is computed based on the input. They are used for modifying or transforming data as it passes through the stream pipeline (e.g., Gzip compression, CSV parsing, encryption)."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "const { Transform } = require('stream');\nconst fs = require('fs');\n\nclass UppercaseTransform extends Transform {\n  _transform(chunk, encoding, callback) {\n    // Convert chunk to string, uppercase it, then push it to the readable side\n    const uppercasedChunk = chunk.toString().toUpperCase();\n    this.push(uppercasedChunk);\n    callback(); // Signal that processing of this chunk is done\n  }\n}\n\nconst readableFile = fs.createReadStream('input.txt'); // Assume input.txt contains \"hello world\"\nconst uppercaseTransformer = new UppercaseTransform();\nconst writableFile = fs.createWriteStream('output_uppercase.txt');\n\n// Pipe: readable -> transform -> writable\nreadableFile.pipe(uppercaseTransformer).pipe(writableFile);\n\nwritableFile.on('finish', () => {\n  console.log('Uppercase transformation complete. Check output_uppercase.txt');\n});"
      },
      {
        "type": "explanation",
        "text": "The `UppercaseTransform` class extends `stream.Transform` and implements the `_transform` method. This method receives a `chunk` of data, processes it (converts to uppercase), and then uses `this.push()` to pass the transformed data to the next stream in the pipeline. `callback()` signals completion."
      }
    ],
    "quiz": {
      "snippet": "class MyTransform extends Transform {\n  _transform(chunk, encoding, callback) {\n    // this.push(processedChunk);\n    // callback();\n  }\n}",
      "questionText": "In a custom Node.js Transform stream, what is the role of the `this.push(data)` method inside `_transform`?",
      "options": [
        "To signal an error in the stream.",
        "To pause the readable side of the stream.",
        "To add the processed data chunk to the readable output of the transform stream.",
        "To close the writable side of the stream."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "`this.push(data)` is used within a Transform stream's `_transform` method to output the processed data. This data then becomes available to be read by the next stream in a pipeline or by a consumer."
    }
  },
  {
    "id": "nodejs-advanced-crypto-004",
    "title": "Cryptography: Hashing and Encryption (Basic)",
    "difficulty": "advanced",
    "framework": "Node.js",
    "frameworkIconText": "Node",
    "tags": ["crypto", "hashing", "sha256", "encryption", "aes", "security"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Node.js's built-in `crypto` module provides cryptographic functionality, including hashing algorithms (like SHA256 for creating fixed-size digests of data, useful for password storage) and encryption/decryption ciphers (like AES)."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "const crypto = require('crypto');\n\n// Hashing example\nconst secret = 'mysecretpassword';\nconst hash = crypto.createHash('sha256').update(secret).digest('hex');\nconsole.log('SHA256 Hash:', hash);\n\n// Basic Encryption/Decryption Example (AES-256-CBC)\nconst algorithm = 'aes-256-cbc';\n// Key must be 32 bytes for AES-256\nconst key = crypto.randomBytes(32);\n// IV must be 16 bytes for AES-CBC\nconst iv = crypto.randomBytes(16);\n\nfunction encrypt(text) {\n  let cipher = crypto.createCipheriv(algorithm, Buffer.from(key), iv);\n  let encrypted = cipher.update(text);\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\n  return { iv: iv.toString('hex'), encryptedData: encrypted.toString('hex') };\n}\n\nfunction decrypt(textObj) {\n  let iv = Buffer.from(textObj.iv, 'hex');\n  let encryptedText = Buffer.from(textObj.encryptedData, 'hex');\n  let decipher = crypto.createDecipheriv(algorithm, Buffer.from(key), iv);\n  let decrypted = decipher.update(encryptedText);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n  return decrypted.toString();\n}\n\nconst hw = encrypt(\"Hello Cryptography!\");\nconsole.log('Encrypted:', hw);\nconsole.log('Decrypted:', decrypt(hw));"
      },
      {
        "type": "explanation",
        "text": "`createHash` generates a hash. For encryption, `createCipheriv` (with an algorithm, key, and initialization vector - IV) is used. `createDecipheriv` is used for decryption. Secure key and IV management is crucial in real applications."
      }
    ],
    "quiz": {
      "snippet": "const hash = crypto.createHash('sha256').update('password123').digest('hex');\n// What is a key characteristic of a good cryptographic hash function like SHA256?",
      "questionText": "What is one of the primary purposes of using a cryptographic hash function (like SHA256) on a piece of data (e.g., a password)?",
      "options": [
        "To compress the data to a smaller size for storage.",
        "To create a reversible, encrypted version of the data.",
        "To generate a fixed-size, unique (with high probability) fingerprint of the data, which is one-way (hard to reverse).",
        "To ensure the data can be transmitted faster over a network."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Cryptographic hash functions produce a fixed-size digest (hash) from input data. They are designed to be one-way (computationally infeasible to reverse) and collision-resistant (very unlikely that two different inputs produce the same hash). This is useful for verifying data integrity and storing password hashes."
    }
  },
  {
    "id": "nodejs-advanced-os-signals-005",
    "title": "Handling OS Signals (e.g., SIGINT, SIGTERM)",
    "difficulty": "advanced",
    "framework": "Node.js",
    "frameworkIconText": "Node",
    "tags": [
      "os signals",
      "SIGINT",
      "SIGTERM",
      "process management",
      "graceful shutdown"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Node.js processes can receive signals from the operating system (e.g., `SIGINT` from Ctrl+C, `SIGTERM` from a shutdown command). You can listen for these signals to perform cleanup operations for a graceful shutdown, like closing database connections or saving state."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "let server; // Assume this is your HTTP or other server instance\n\nfunction gracefulShutdown(signal) {\n  console.log(`\\nReceived ${signal}. Starting graceful shutdown...`);\n  // 1. Stop accepting new connections (if applicable)\n  // server.close(() => {\n  //   console.log('HTTP server closed.');\n    // 2. Close database connections, etc.\n    // db.close(() => { console.log('Database connection closed.'); });\n    // 3. Exit process\n    process.exit(0);\n  // });\n\n  // If server.close is not used, or for non-server apps:\n  console.log('Performing cleanup tasks...');\n  // Simulate cleanup\n  setTimeout(() => {\n    console.log('Cleanup finished. Exiting.');\n    process.exit(0);\n  }, 1000);\n}\n\n// Listen for SIGINT (Ctrl+C)\nprocess.on('SIGINT', () => gracefulShutdown('SIGINT'));\n\n// Listen for SIGTERM (e.g., from `kill` command or process managers)\nprocess.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n\nconsole.log('Application running... Press Ctrl+C to test SIGINT.');\n// Keep the process alive for testing\nsetInterval(() => { /* keep alive */ }, 1000 * 60);"
      },
      {
        "type": "explanation",
        "text": "`process.on('SIGINT', callback)` registers a listener for the `SIGINT` signal. The callback `gracefulShutdown` is then executed, allowing the application to perform cleanup before exiting with `process.exit(0)`."
      }
    ],
    "quiz": {
      "snippet": "process.on('SIGTERM', () => {\n  console.log('SIGTERM received, cleaning up...');\n  // Perform cleanup\n  process.exit(0);\n});",
      "questionText": "What is a common reason for a Node.js application to listen for OS signals like `SIGINT` or `SIGTERM`?",
      "options": [
        "To automatically restart the application if it crashes.",
        "To detect changes in the file system.",
        "To perform graceful shutdown procedures, like closing database connections or saving state, before the process exits.",
        "To receive messages from other Node.js processes."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Listening for signals like `SIGINT` (Ctrl+C) or `SIGTERM` (termination signal) allows a Node.js application to execute cleanup code (e.g., close connections, save pending data) for a graceful shutdown, rather than being abruptly terminated by the OS."
    }
  },
  {
    "id": "svelte-advanced-transitions-custom-001",
    "title": "Custom JS Transitions & Animation Directives",
    "difficulty": "advanced",
    "framework": "Svelte",
    "frameworkIconText": "Svelte",
    "tags": [
      "transitions",
      "animations",
      "svelte/transition",
      "js transitions",
      "directives"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Svelte provides powerful built-in transition directives (`fade`, `fly`, `slide`, etc.). For more complex animations, you can create custom JavaScript transitions. These are functions that receive the DOM node and parameters, and return an object describing the animation (duration, delay, easing, css, tick)."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<!-- CustomTransition.svelte -->\n<script>\n  import { cubicOut } from 'svelte/easing';\n  let visible = true;\n\n  function customSpin(node, { duration = 400, delay = 0 }) {\n    return {\n      duration,\n      delay,\n      css: t => {\n        const eased = cubicOut(t);\n        return `\n          opacity: ${eased};\n          transform: scale(${eased}) rotate(${eased * 360}deg);\n        `;\n      }\n    };\n  }\n</script>\n\n<label>\n  <input type=\"checkbox\" bind:checked={visible}>\n  Toggle Visibility\n</label>\n\n{#if visible}\n  <div class=\"box\" transition:customSpin={{ duration: 1000 }}>\n    Spins in and out!\n  </div>\n{/if}\n\n<style>\n  .box { padding: 1em; background-color: teal; color: white; margin-top: 1em; }\n</style>"
      },
      {
        "type": "explanation",
        "text": "The `customSpin` function defines a JavaScript transition. It uses the `css` property to return a string of CSS styles that are applied over time (`t` goes from 0 to 1 for 'in' transitions, and 1 to 0 for 'out'). `cubicOut` is an easing function. The transition is applied using `transition:customSpin`."
      }
    ],
    "quiz": {
      "snippet": "function myTransition(node, params) {\n  return {\n    duration: params.duration,\n    tick: (t, u) => { /* u = 1 - t */ \n      node.style.setProperty('opacity', t);\n    }\n  };\n}\n// <div transition:myTransition={{ duration: 500 }}>...</div>",
      "questionText": "In a custom Svelte JS transition, what does the `tick(t, u)` function primarily do?",
      "options": [
        "It defines the total duration of the animation.",
        "It's called on every frame of the animation, allowing programmatic updates to the node's style or attributes based on progress `t`.",
        "It sets up initial CSS styles before the animation starts.",
        "It's a cleanup function called after the animation completes."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "The `tick(t, u)` function in a custom JS transition is called on each animation frame. `t` represents the progress of an 'in' transition (0 to 1), and `u` is `1 - t` (progress of an 'out' transition). Inside `tick`, you programmatically update the node's properties."
    }
  },
  {
    "id": "svelte-advanced-actions-002",
    "title": "Reusable DOM Behavior with Actions",
    "difficulty": "advanced",
    "framework": "Svelte",
    "frameworkIconText": "Svelte",
    "tags": [
      "actions",
      "use:action",
      "dom manipulation",
      "reusability",
      "lifecycle"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Actions are functions that run when an element is created. They can return an object with `update` and `destroy` methods, allowing you to manage an element's lifecycle or integrate with third-party libraries. They are applied to elements using the `use:actionName` directive."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<!-- LongPressAction.svelte (or just a .js file exporting the action) -->\n<script>\n  // This could be in a separate .js file and imported\n  export function longpress(node, duration = 500) {\n    let timer;\n\n    function handleMousedown() {\n      timer = setTimeout(() => {\n        node.dispatchEvent(new CustomEvent('longpress'));\n      }, duration);\n    }\n\n    function handleMouseup() {\n      clearTimeout(timer);\n    }\n\n    node.addEventListener('mousedown', handleMousedown);\n    node.addEventListener('mouseup', handleMouseup);\n\n    return {\n      update(newDuration) {\n        // Called when the parameter to the action changes\n        duration = newDuration;\n      },\n      destroy() {\n        // Called when the element is removed from the DOM\n        node.removeEventListener('mousedown', handleMousedown);\n        node.removeEventListener('mouseup', handleMouseup);\n        clearTimeout(timer);\n        console.log('Longpress action destroyed');\n      }\n    };\n  }\n</script>\n\n<!-- App.svelte (Usage) -->\n<!-- \n<script>\n  import { longpress } from './LongPressAction.svelte'; // Or from './actions.js'\n  function handleLongPress() {\n    alert('Long press detected!');\n  }\n</script>\n\n<button use:longpress={1000} on:longpress={handleLongPress}>\n  Press and Hold Me (1s)\n</button>\n-->"
      },
      {
        "type": "explanation",
        "text": "The `longpress` action attaches mousedown/mouseup listeners to the element. If the mouse is held down for the specified `duration`, it dispatches a custom `longpress` event. The `destroy` method cleans up the event listeners when the element is removed."
      }
    ],
    "quiz": {
      "snippet": "function myAction(node, options) {\n  // ... setup ...\n  return {\n    update(newOptions) { /* ... */ },\n    destroy() { /* ... cleanup ... */ }\n  };\n}\n// <div use:myAction={someOptions}>...</div>",
      "questionText": "In a Svelte action, when is the `destroy` method (if returned by the action function) called?",
      "options": [
        "Every time the action's parameters update.",
        "Only once when the action is first applied to the element.",
        "When the element the action is applied to is removed from the DOM.",
        "When a specific event is dispatched by the action."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "The `destroy` method returned by a Svelte action is called when the element to which the action is applied is unmounted (removed from the DOM). This is used for cleanup, like removing event listeners or timers."
    }
  },
  {
    "id": "svelte-advanced-context-api-003",
    "title": "Dependency Injection with Context API",
    "difficulty": "advanced",
    "framework": "Svelte",
    "frameworkIconText": "Svelte",
    "tags": [
      "context api",
      "setContext",
      "getContext",
      "dependency injection",
      "state management"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Svelte's context API provides a way for a component to pass data to its descendants without explicitly passing props through every intermediate component (similar to React Context or Vue Provide/Inject). It uses `setContext` in an ancestor and `getContext` in a descendant."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<!-- ThemeProvider.svelte -->\n<script>\n  import { setContext } from 'svelte';\n  import { writable } from 'svelte/store';\n\n  // Create a writable store for the theme\n  const theme = writable('light');\n  \n  // Set the context with a key and the store/functions\n  setContext('theme-context', {\n    currentTheme: theme, // Pass the store itself\n    toggleTheme: () => theme.update(t => t === 'light' ? 'dark' : 'light')\n  });\n</script>\n\n<slot></slot> <!-- Content from parent will go here -->\n\n\n<!-- DeepChild.svelte -->\n<!-- \n<script>\n  import { getContext } from 'svelte';\n  const { currentTheme, toggleTheme } = getContext('theme-context');\n</script>\n\n<div style=\"background-color: {$currentTheme === 'dark' ? '#333' : '#fff'}; color: {$currentTheme === 'dark' ? '#fff' : '#333'}; padding: 1em;\">\n  Current theme is: {$currentTheme}\n  <button on:click={toggleTheme}>Toggle Theme</button>\n</div>\n-->\n\n<!-- App.svelte (Usage) -->\n<!-- \n<script>\n  import ThemeProvider from './ThemeProvider.svelte';\n  import DeepChild from './DeepChild.svelte';\n</script>\n\n<ThemeProvider>\n  <p>Some content</p>\n  <DeepChild /> \n</ThemeProvider>\n-->"
      },
      {
        "type": "explanation",
        "text": "`ThemeProvider` uses `setContext` to make the `theme` store and `toggleTheme` function available to any descendant component under the key `'theme-context'`. `DeepChild` then uses `getContext('theme-context')` to access these values without them being passed as props through intermediate components."
      }
    ],
    "quiz": {
      "snippet": "// Parent.svelte\n// import { setContext } from 'svelte';\n// setContext('myKey', { data: 'shared' });\n\n// Grandchild.svelte\n// import { getContext } from 'svelte';\n// const ctx = getContext('myKey');",
      "questionText": "What is the primary purpose of Svelte's `setContext` and `getContext` API?",
      "options": [
        "To manage component-local reactive state.",
        "To directly manipulate DOM elements outside the component.",
        "To pass data deeply through the component tree without explicit prop drilling.",
        "To define custom HTML tags."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Svelte's context API (`setContext` and `getContext`) is designed for dependency injection, allowing an ancestor component to make data or functions available to any of its descendant components without needing to pass them down manually as props through each intermediate level."
    }
  },
  {
    "id": "svelte-advanced-ssr-considerations-004",
    "title": "Server-Side Rendering (SSR) Considerations (with SvelteKit)",
    "difficulty": "advanced",
    "framework": "Svelte",
    "frameworkIconText": "SvelteKit",
    "tags": ["ssr", "sveltekit", "load function", "universal code", "onMount"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "SvelteKit is the official framework for building Svelte applications, and it supports SSR out of the box. When writing SvelteKit apps, you need to be mindful of code that can only run on the client (e.g., accessing `window` or `document`) versus code that can run on the server (e.g., in `load` functions)."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<!-- src/routes/posts/[slug].svelte (SvelteKit example) -->\n<script context=\"module\">\n  // This 'load' function runs on the server (during SSR) and client (during navigation)\n  export async function load({ params, fetch }) {\n    // 'fetch' is a SvelteKit-provided fetch that works универсально\n    const res = await fetch(`https://api.example.com/posts/${params.slug}.json`);\n    const post = await res.json();\n\n    if (res.ok) {\n      return { props: { post } };\n    }\n    return { status: res.status, error: new Error(`Could not load ${params.slug}`) };\n  }\n</script>\n\n<script>\n  export let post;\n  import { onMount } from 'svelte';\n\n  onMount(() => {\n    // This code ONLY runs on the client after the component is mounted\n    console.log('Post component mounted on client. Title:', post.title);\n    // DOM manipulations or browser-specific APIs would go here.\n  });\n</script>\n\n<h1>{post.title}</h1>\n<div>{@html post.content}</div>"
      },
      {
        "type": "explanation",
        "text": "The `load` function in the `<script context=\"module\">` block is SvelteKit's way to fetch data for a page before it's rendered. It can run on both server and client. Code inside the main `<script>` tag (especially in `onMount`) that accesses browser-specific globals like `window` will only run on the client after hydration."
      }
    ],
    "quiz": {
      "snippet": "// src/routes/my-page.svelte (SvelteKit)\n<script context=\"module\">\n  export async function load({ fetch }) { /* ... fetches data ... */ }\n</script>\n<script>\n  import { onMount } from 'svelte';\n  onMount(() => { document.title = 'My Page Title'; });\n</script>",
      "questionText": "In a SvelteKit page component, where is it safe to directly access browser-specific globals like `document` or `window` without causing errors during SSR?",
      "options": [
        "Anywhere in the `<script context=\"module\">` block",
        "Directly in the main `<script>` block's top level",
        "Inside the `load` function",
        "Inside lifecycle functions that only run on the client, like `onMount`"
      ],
      "correctOptionIndex": 3,
      "explanationAfterAnswer": "Code that relies on browser-specific APIs (like `document` or `window`) should be placed inside client-side lifecycle functions like `onMount` or wrapped in a check like `if (browser)` (where `browser` is imported from `$app/environment`). The `load` function and top-level of `<script context=\"module\">` can run on the server."
    }
  },
  {
    "id": "svelte-advanced-custom-stores-005",
    "title": "Creating Custom Stores with Complex Logic",
    "difficulty": "advanced",
    "framework": "Svelte",
    "frameworkIconText": "Svelte",
    "tags": [
      "stores",
      "custom stores",
      "writable",
      "subscribe",
      "set",
      "update",
      "state management"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "While `writable` stores are versatile, sometimes you need a store with more complex internal logic or custom methods. You can create custom stores by implementing the store contract (a `subscribe` method, and optionally `set` and `update` methods if it's writable)."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// timerStore.js\nimport { writable } from 'svelte/store';\n\nfunction createTimerStore(initialSeconds = 60) {\n  const { subscribe, set, update } = writable(initialSeconds);\n  let intervalId;\n\n  function start() {\n    clearInterval(intervalId); // Clear any existing interval\n    set(initialSeconds); // Reset to initial value\n    intervalId = setInterval(() => {\n      update(seconds => {\n        if (seconds > 0) {\n          return seconds - 1;\n        } else {\n          clearInterval(intervalId);\n          // Optionally dispatch an event or perform an action when timer ends\n          console.log('Timer finished!');\n          return 0;\n        }\n      });\n    }, 1000);\n  }\n\n  function stop() {\n    clearInterval(intervalId);\n  }\n\n  function reset() {\n    clearInterval(intervalId);\n    set(initialSeconds);\n  }\n\n  return {\n    subscribe, // Expose the subscribe method for Svelte's reactivity\n    start,\n    stop,\n    reset\n    // Cannot directly expose set/update if you want controlled mutations\n  };\n}\n\nexport const timer = createTimerStore(30); // Create an instance with 30 seconds\n\n// Usage in a component:\n// import { timer } from './timerStore.js';\n// <p>Time left: {$timer}</p> \n// <button on:click={timer.start}>Start</button>\n// <button on:click={timer.stop}>Stop</button>"
      },
      {
        "type": "explanation",
        "text": "`createTimerStore` is a factory function for a custom store. It uses an internal `writable` store but exposes custom methods (`start`, `stop`, `reset`) to interact with the timer's state. Only `subscribe` from the internal writable store is exposed directly to make it a valid Svelte store."
      }
    ],
    "quiz": {
      "snippet": "// myCustomStore.js\n// import { writable } from 'svelte/store';\n// export function createMyStore() {\n//   const { subscribe, update } = writable({ value: 0 });\n//   return {\n//     subscribe,\n//     increment: () => update(s => ({ value: s.value + 1}))\n//   };\n// }",
      "questionText": "To make a custom store object (like the one returned by `createMyStore`) work with Svelte's `$` auto-subscription, which method *must* it expose?",
      "options": [
        "A `get()` method",
        "A `set(value)` method",
        "A `subscribe(run, invalidate)` method",
        "An `update(updaterFn)` method"
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "For Svelte's `$` auto-subscription syntax to work, the store object must adhere to the store contract, which minimally requires it to have a `subscribe` method. This method takes a callback function that is called with the store's value whenever it changes."
    }
  },
  {
    "id": "nuxtjs-advanced-nitro-custom-storage-001",
    "title": "Nitro: Custom Storage Layers & Caching",
    "difficulty": "advanced",
    "framework": "Nuxt.js",
    "frameworkIconText": "NuxtNitro",
    "tags": [
      "nitro",
      "server engine",
      "storage layer",
      "caching",
      "server-side"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Nitro, Nuxt's server engine, provides a powerful storage layer abstraction. You can define custom storage drivers (e.g., for Redis, S3, databases) or use built-in ones (like memory, fs). This is crucial for advanced caching strategies, session management, or persisting data server-side."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// server/utils/kv.ts (Example of using built-in KV storage)\n// This demonstrates using the unstorage abstraction that Nitro provides.\n// In a real custom driver, you'd implement the unstorage interface.\n// For this example, let's imagine configuring a built-in or community driver.\n\n// nuxt.config.ts (Conceptual - actual driver setup might vary)\n// export default defineNuxtConfig({\n//   nitro: {\n//     storage: {\n//       'myCache': {\n//         driver: 'redis', // Or 'fs', 'memory', or a custom driver path\n//         /* driver specific options */\n//         host: 'localhost',\n//         port: 6379\n//       }\n//     }\n//   }\n// })\n\n// server/api/cached-data.get.ts\n// import { useStorage } from '#imports'; // Auto-imported by Nuxt\n\n// export default defineEventHandler(async (event) => {\n//   const storage = useStorage('myCache'); // Use the configured storage\n//   const cacheKey = 'expensive-data';\n\n//   let data = await storage.getItem(cacheKey);\n//   if (!data) {\n//     console.log('Cache miss, fetching new data...');\n//     // data = await fetchExpensiveOperation(); // Simulate fetching\n//     data = { message: 'Freshly fetched data', timestamp: Date.now() };\n//     await storage.setItem(cacheKey, data, { ttl: 300 }); // Cache for 5 minutes\n//   }\n//   return data;\n// });"
      },
      {
        "type": "explanation",
        "text": "Nitro's storage layer uses `unstorage` which provides a key-value interface. You configure storage mounts in `nuxt.config.ts`. In server routes or plugins, `useStorage('mountName')` gives access to the storage instance for `getItem`, `setItem`, `hasItem`, etc., enabling sophisticated server-side caching or data persistence strategies beyond simple in-memory caching."
      }
    ],
    "quiz": {
      "snippet": "// server/api/user-prefs.get.ts\n// const storage = useStorage('user_sessions');\n// const prefs = await storage.getItem(`session:${userId}`);\n// What is Nitro's storage layer primarily used for?",
      "questionText": "What is a key capability provided by Nitro's storage layer in Nuxt 3?",
      "options": [
        "Client-side browser localStorage abstraction.",
        "A unified key-value interface for various server-side storage backends (memory, file system, Redis, etc.) for caching and persistence.",
        "Managing static assets in the `public/` directory.",
        "Storing Vue component state directly on the server."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "Nitro's storage layer, built on `unstorage`, provides a flexible key-value store abstraction that can be backed by different drivers (memory, fs, Redis, S3, etc.). This is primarily for server-side caching, session data, or other forms of server-side data persistence."
    }
  },
  {
    "id": "nuxtjs-advanced-module-authoring-002",
    "title": "Nuxt Module Authoring (Basic)",
    "difficulty": "advanced",
    "framework": "Nuxt.js",
    "frameworkIconText": "NuxtMod",
    "tags": [
      "nuxt modules",
      "extend nuxt",
      "hooks",
      "plugins",
      "build process"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Nuxt modules are functions that can extend Nuxt's core functionality, add integrations, or modify the build process. They can register plugins, components, server routes, interact with Nuxt hooks, and much more. This is how many community integrations (like Tailwind CSS, Pinia) are provided."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// modules/simple-logger-module.ts\nimport { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit';\n\nexport default defineNuxtModule({\n  meta: {\n    name: 'my-simple-logger',\n    configKey: 'simpleLogger' // Optional: key in nuxt.config for module options\n  },\n  // Default configuration options for your module\n  defaults: {\n    prefix: '[Logger]'\n  },\n  setup(options, nuxt) {\n    const resolver = createResolver(import.meta.url);\n\n    // Add a server plugin\n    addPlugin(resolver.resolve('./runtime/logger.server')); // Points to a file in ./runtime\n\n    // Add a client plugin\n    // addPlugin(resolver.resolve('./runtime/logger.client'));\n\n    // You can access Nuxt hooks, e.g., to modify webpack/vite config\n    // nuxt.hook('vite:extendConfig', (viteInlineConfig, { isClient, isServer }) => { ... });\n\n    console.log('My Simple Logger Module initialized with prefix:', options.prefix);\n  }\n});\n\n// runtime/logger.server.ts (example server plugin provided by the module)\n// export default defineNuxtPlugin((nuxtApp) => {\n//   const moduleOptions = nuxtApp.payload.config.public.simpleLogger || { prefix: '[Default Logger]' }; \n//   console.log(`${moduleOptions.prefix} Server plugin from module reporting!`);\n//   nuxtApp.hook('request', (event) => {\n//     console.log(`${moduleOptions.prefix} Request to: ${event.node.req.url}`);\n//   });\n// });\n\n// nuxt.config.ts (to use the module)\n// export default defineNuxtConfig({\n//   modules: [\n//     './modules/simple-logger-module' // Path to your local module\n//   ],\n//   simpleLogger: { // Optional configuration for the module\n//     prefix: '[AppLogger]'\n//   }\n// })"
      },
      {
        "type": "explanation",
        "text": "A Nuxt module is defined with `defineNuxtModule`. The `setup` function is the core, where you can use utilities from `@nuxt/kit` like `addPlugin`, `addServerHandler`, or hook into Nuxt's lifecycle. Modules allow for clean, reusable extensions to Nuxt."
      }
    ],
    "quiz": {
      "snippet": "// modules/my-custom-module.ts\n// import { defineNuxtModule, addServerHandler } from '@nuxt/kit';\n// export default defineNuxtModule({\n//   setup(options, nuxt) {\n//     addServerHandler({ route: '/api/custom', handler: '~/server/api/custom.get.ts' })\n//   }\n// });",
      "questionText": "What is a primary purpose of creating a Nuxt module?",
      "options": [
        "To define global CSS styles for the application.",
        "To create reusable Vue components only.",
        "To extend Nuxt's core functionality, integrate third-party services, or modify the build process in a shareable and configurable way.",
        "To manage client-side browser storage like localStorage."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Nuxt modules are designed to extend or modify Nuxt. They can add plugins, components, server handlers, modify configurations, and hook into various parts of Nuxt's lifecycle, providing a structured way to add reusable functionality."
    }
  },
  {
    "id": "nuxtjs-advanced-rendering-modes-003",
    "title": "Advanced Rendering Modes & Strategies",
    "difficulty": "advanced",
    "framework": "Nuxt.js",
    "frameworkIconText": "Nuxt",
    "tags": [
      "rendering modes",
      "ssr",
      "ssg",
      "csr",
      "hybrid rendering",
      "route rules"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Nuxt 3 offers flexible rendering modes. By default, it's universal (SSR on first load, CSR for navigations). You can configure per-route rendering behavior (SSR, SSG, CSR) using route rules in `nuxt.config.ts` or by defining `ssr: false` or `target: 'static'` (for full SSG in older Nuxt/Nitro versions, now more nuanced with Nitro presets)."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// nuxt.config.ts\nexport default defineNuxtConfig({\n  // Global SSR setting (true by default)\n  // ssr: true, \n\n  routeRules: {\n    // Force SSR for admin pages\n    '/admin/**': { ssr: true },\n    // Generate blog posts as static at build time (SSG)\n    '/blog/**': { static: true }, // or { prerender: true }\n    // Specific blog post with ISR (revalidates every 60s)\n    '/blog/popular-post': { isr: 60 },\n    // Make /dashboard a client-side rendered SPA\n    '/dashboard/**': { ssr: false },\n    // Redirect\n    '/old-page': { redirect: '/new-page' },\n    // Add headers\n    '/api/**': { headers: { 'cache-control': 's-maxage=3600' } }\n  },\n\n  // For full static site generation (Nuxt 2 style, less common for Nuxt 3 apps with server needs):\n  // nitro: {\n  //   preset: 'static' // or other presets like 'vercel-static', 'cloudflare-pages'\n  // }\n});\n\n// pages/dashboard/index.vue (Example for CSR)\n// <script setup>\n// definePageMeta({ ssr: false }); // Another way to set per-page\n// </script>"
      },
      {
        "type": "explanation",
        "text": "`routeRules` in `nuxt.config.ts` allows fine-grained control over how different routes are rendered, cached, or handled. `ssr: false` makes a route client-side rendered. `static: true` (or `prerender: true`) aims for SSG. `isr: <seconds>` enables Incremental Static Regeneration."
      }
    ],
    "quiz": {
      "snippet": "// nuxt.config.ts\n// routeRules: {\n//   '/docs/**': { static: true },\n//   '/app/**': { ssr: false }\n// }",
      "questionText": "If a Nuxt 3 application has `'/app/**': { ssr: false }` in its `routeRules`, how will pages under `/app/` primarily behave?",
      "options": [
        "They will always be server-side rendered on every request.",
        "They will be pre-rendered as static HTML at build time.",
        "They will be rendered primarily on the client-side, behaving like a Single Page Application (SPA) for those routes.",
        "They will be served from an Edge cache with ISR."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "`ssr: false` for a route group means those pages will not be server-side rendered. Instead, Nuxt will serve a minimal HTML shell, and the page will be rendered by Vue.js in the client's browser, similar to a traditional SPA."
    }
  },
  {
    "id": "nuxtjs-advanced-typed-api-trpc-004",
    "title": "Type-Safe APIs (e.g., with tRPC concept)",
    "difficulty": "advanced",
    "framework": "Nuxt.js",
    "frameworkIconText": "NuxtTS",
    "tags": ["type safety", "api", "trpc", "full-stack", "typescript", "nitro"],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "While Nuxt's server API routes are powerful, ensuring type safety between your frontend and backend API calls can be challenging. Libraries like tRPC (or similar patterns) allow you to define your API schema once (often with Zod for validation) and get auto-generated, type-safe client-side callers, eliminating common integration bugs."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// This is a conceptual example of how one might structure tRPC-like type safety with Nuxt.\n// Actual tRPC integration with Nuxt involves a community module or custom setup.\n\n// server/trpc/routers/post.ts (Example tRPC router definition)\n// import { z } from 'zod';\n// import { publicProcedure, router } from '../trpc'; // Your tRPC setup\n// export const postRouter = router({\n//   getById: publicProcedure\n//     .input(z.object({ id: z.string() }))\n//     .query(async ({ input, ctx }) => {\n//       // const post = await ctx.db.post.findUnique({ where: { id: input.id } });\n//       // return post;\n//       return { id: input.id, title: `Post ${input.id}`, content: 'Content...' };\n//     }),\n//   create: publicProcedure\n//     .input(z.object({ title: z.string(), content: z.string() }))\n//     .mutation(async ({ input, ctx }) => {\n//       // const newPost = await ctx.db.post.create({ data: input });\n//       // return newPost;\n//       return { ...input, id: Math.random().toString(36).substring(7) };\n//     }),\n// });\n\n// server/trpc/index.ts (Main app router)\n// import { router } from './trpc';\n// import { postRouter } from './routers/post';\n// export const appRouter = router({ post: postRouter });\n// export type AppRouter = typeof appRouter;\n\n// plugins/trpc-client.ts (Client-side tRPC setup)\n// import { createTRPCNuxtClient, httpBatchLink } from 'trpc-nuxt/client';\n// import type { AppRouter } from '~/server/trpc'; // Import router type\n// export default defineNuxtPlugin(() => {\n//   const client = createTRPCNuxtClient<AppRouter>({\n//     links: [ httpBatchLink({ url: '/api/trpc' }) ], // Nuxt proxy for /api/trpc\n//   });\n//   return { provide: { trpc: client } };\n// });\n\n// Component usage:\n// const { $trpc } = useNuxtApp();\n// const { data: post, error } = await $trpc.post.getById.useQuery({ id: '123' });\n// const { mutate: createPost } = $trpc.post.create.useMutation();\n// createPost({ title: 'New Post', content: '...' });"
      },
      {
        "type": "explanation",
        "text": "With tRPC, you define procedures (queries, mutations) on the server using TypeScript. The client can then call these procedures in a fully type-safe manner, with autocompletion for inputs and outputs. Nuxt can proxy tRPC requests through its server engine."
      }
    ],
    "quiz": {
      "snippet": "// Client-side code using a tRPC-like type-safe API client:\n// const { data, error } = await trpcClient.user.getUserProfile.useQuery({ userId: 'abc' });\n// If `getUserProfile` on the server expects `userId` as a number, what happens?",
      "questionText": "What is a significant advantage of using a framework like tRPC for building APIs in a full-stack TypeScript application (like Nuxt)?",
      "options": [
        "It automatically handles user authentication and authorization.",
        "It provides end-to-end type safety between the client and server, reducing integration errors and improving developer experience.",
        "It eliminates the need for a database on the backend.",
        "It only allows GraphQL queries for data fetching."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "tRPC and similar solutions leverage TypeScript to provide type safety across the API boundary. You define your API schema once on the server, and the client gets type-checked callers, autocompletion, and inference, which helps catch errors at compile time rather than runtime."
    }
  },
  {
    "id": "nuxtjs-advanced-island-architecture-concept-005",
    "title": "Island Architecture & Server Components (Conceptual Future)",
    "difficulty": "advanced",
    "framework": "Nuxt.js",
    "frameworkIconText": "Nuxt",
    "tags": [
      "island architecture",
      "partial hydration",
      "server components",
      "performance",
      "future"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "While Nuxt 3 primarily uses Universal Rendering (SSR + client-side hydration), the broader web development trend includes concepts like Island Architecture and React Server Components (RSC). The idea is to serve mostly static HTML from the server, with small, isolated 'islands' of interactivity that are hydrated on the client. Nuxt's Nitro server and Vue's Vapor mode are exploring similar directions for highly performant applications."
      },
      {
        "type": "code",
        "language": "text",
        "code": "// Conceptual - Svelte/Vue are evolving towards more granular hydration\n// Imagine a future Nuxt where some components are explicitly server-rendered only,\n// and others are client-hydrated 'islands'.\n\n// my-page.vue\n// <template>\n//   <StaticHeader /> <!-- Always static HTML from server -->\n//   <main>\n//     <MostlyStaticContent />\n//     <InteractiveCommentSection client:visible /> \n//     <!-- 'client:visible' could be a directive to hydrate only when visible -->\n//   </main>\n//   <StaticFooter />\n// </template>\n\n// InteractiveCommentSection.vue (would be a client component)\n// <script setup>\n//   // state, event handlers, etc.\n// </script>"
      },
      {
        "type": "explanation",
        "text": "The goal is to minimize the amount of JavaScript shipped to and executed on the client by rendering as much as possible to static HTML on the server. Only components that *need* client-side interactivity become hydrated 'islands'. Nuxt's server components (`.server.vue` files) and client components (`.client.vue` files) are steps in this direction, allowing more control over where rendering and execution happens."
      }
    ],
    "quiz": {
      "snippet": "// A page with mostly static content but one interactive widget.\n// What is the core idea behind 'Island Architecture' or partial hydration?",
      "questionText": "What is the main goal of Island Architecture or partial hydration in modern web frameworks?",
      "options": [
        "To ensure all JavaScript runs exclusively on the server.",
        "To render the entire application on the client-side for better interactivity.",
        "To minimize client-side JavaScript by server-rendering most of the page as static HTML and only hydrating small, isolated interactive components ('islands').",
        "To use WebAssembly for all client-side logic."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Island Architecture aims to improve performance by reducing the client-side JavaScript footprint. The majority of the page is server-rendered as static HTML, and only specific interactive sections (the 'islands') are hydrated and made dynamic on the client."
    }
  },
  {
    "id": "nestjs-advanced-microservices-nats-001",
    "title": "Microservices Communication (e.g., with NATS/Redis)",
    "difficulty": "advanced",
    "framework": "NestJS",
    "frameworkIconText": "NestMicro",
    "tags": [
      "microservices",
      "nats",
      "redis",
      "message patterns",
      "event patterns",
      "distributed systems"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "NestJS provides excellent support for building microservices that communicate via various transport layers like TCP, Redis, NATS, Kafka, gRPC, etc. This involves defining message/event patterns for inter-service communication instead of traditional HTTP requests."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// Math Service (microservice listening for messages)\n// src/math.controller.ts\n// import { Controller } from '@nestjs/common';\n// import { MessagePattern, Payload } from '@nestjs/microservices';\n// \n// @Controller()\n// export class MathController {\n//   @MessagePattern({ cmd: 'sum' }) // Listens for messages with this pattern\n//   accumulate(@Payload() data: number[]): number {\n//     return (data || []).reduce((a, b) => a + b, 0);\n//   }\n// }\n// main.ts (for math service)\n// async function bootstrap() {\n//   const app = await NestFactory.createMicroservice<MicroserviceOptions>(\n//     AppModule, // Assume MathController is in AppModule's controllers\n//     { transport: Transport.NATS, options: { servers: ['nats://localhost:4222'] } },\n//   );\n//   await app.listen();\n//   console.log('Math microservice is listening on NATS');\n// }\n\n// API Gateway (sends messages to microservice)\n// src/api-gateway.controller.ts\n// import { Controller, Get, Inject, OnModuleInit } from '@nestjs/common';\n// import { ClientProxy } from '@nestjs/microservices';\n// \n// @Controller('calculate')\n// export class ApiGatewayController implements OnModuleInit {\n//   constructor(@Inject('MATH_SERVICE') private client: ClientProxy) {}\n//   async onModuleInit() { await this.client.connect(); }\n// \n//   @Get('add')\n//   async addNumbers() {\n//     return this.client.send({ cmd: 'sum' }, [1, 2, 3, 4, 5]); // Sends a message\n//   }\n// }\n// AppModule for API Gateway would register ClientsModule.register(...)"
      },
      {
        "type": "explanation",
        "text": "The Math service listens for messages with a specific pattern (`{ cmd: 'sum' }`) using `@MessagePattern`. The API Gateway uses a `ClientProxy` to send messages to this service. This decouples services, allowing them to scale independently. NATS is just one example transporter; Redis, Kafka, RabbitMQ, etc., are also common."
      }
    ],
    "quiz": {
      "snippet": "// Microservice A (listener)\n// @MessagePattern('user.created')\n// handleUserCreated(@Payload() data: UserDto) { /* ... */ }\n\n// Microservice B (emitter)\n// this.client.emit('user.created', newUserDto);",
      "questionText": "In a NestJS microservices architecture, what is a key difference between `client.send()` (message pattern) and `client.emit()` (event pattern)?",
      "options": [
        "`send()` is for synchronous communication, `emit()` for asynchronous.",
        "`send()` expects a response from the listening service, while `emit()` is typically for fire-and-forget events where no direct response is expected by the emitter.",
        "`emit()` can only send strings, `send()` can send complex objects.",
        "`send()` uses TCP, `emit()` uses UDP by default."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "`client.send()` is used for request-response style communication (message pattern), where the sender expects a reply from the microservice. `client.emit()` is used for event-based communication (event pattern), where the sender broadcasts an event without necessarily expecting a direct response."
    }
  },
  {
    "id": "nestjs-advanced-graphql-resolvers-002",
    "title": "GraphQL API with Code-First or Schema-First Approach",
    "difficulty": "advanced",
    "framework": "NestJS",
    "frameworkIconText": "NestGraphQL",
    "tags": [
      "graphql",
      "@nestjs/graphql",
      "resolvers",
      "schemas",
      "queries",
      "mutations"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "NestJS provides excellent integration with GraphQL via the `@nestjs/graphql` module. You can build your GraphQL API using either a code-first approach (defining schema via TypeScript classes and decorators) or a schema-first approach (writing GraphQL SDL)."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// Code-First Approach Example\n// src/recipes/recipe.model.ts\n// import { ObjectType, Field, ID, Int } from '@nestjs/graphql';\n// @ObjectType()\n// export class Recipe {\n//   @Field(type => ID)\n//   id: string;\n//   @Field()\n//   title: string;\n//   @Field(type => Int, { nullable: true })\n//   ratings?: number;\n// }\n\n// src/recipes/recipes.resolver.ts\n// import { Resolver, Query, Args, Mutation } from '@nestjs/graphql';\n// import { Recipe } from './recipe.model';\n// // Assume RecipesService exists for data logic\n// @Resolver(of => Recipe)\n// export class RecipesResolver {\n//   constructor(private recipesService: RecipesService) {}\n// \n//   @Query(returns => Recipe, { name: 'recipe' })\n//   async getRecipe(@Args('id', { type: () => String }) id: string) {\n//     return this.recipesService.findOneById(id);\n//   }\n// \n//   @Query(returns => [Recipe])\n//   async recipes() {\n//     return this.recipesService.findAll();\n//   }\n// \n//   @Mutation(returns => Recipe)\n//   async addRecipe(\n//     @Args('title', { type: () => String }) title: string,\n//     @Args('description', { type: () => String, nullable: true }) description?: string\n//   ) {\n//     return this.recipesService.create({ title, description });\n//   }\n// }\n\n// AppModule would import GraphQLModule.forRoot({ autoSchemaFile: true }) for code-first"
      },
      {
        "type": "explanation",
        "text": "In the code-first approach, decorators like `@ObjectType()`, `@Field()`, `@Resolver()`, `@Query()`, and `@Mutation()` are used to define the GraphQL schema and its resolvers directly in TypeScript. NestJS then automatically generates the GraphQL schema."
      }
    ],
    "quiz": {
      "snippet": "// @Resolver(of => Author)\n// export class AuthorResolver {\n//   @Query(returns => Author)\n//   author(@Args('id') id: number) { /* ... */ }\n// \n//   @ResolveField(returns => [Post])\n//   posts(@Parent() author: Author) { /* fetch posts for author */ }\n// }",
      "questionText": "In a NestJS GraphQL resolver (code-first), what is the purpose of a method decorated with `@ResolveField()`?",
      "options": [
        "To define a top-level query for fetching data.",
        "To define a mutation for creating or updating data.",
        "To resolve a specific field on a GraphQL type, often for nested or related data that isn't directly part of the parent object.",
        "To apply an authentication guard to a GraphQL query."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "`@ResolveField()` is used to define a resolver for a specific field within a GraphQL type. This is often used when a field's data needs to be fetched separately or involves some computation, especially for related or nested data (e.g., fetching all posts for an author)."
    }
  },
  {
    "id": "nestjs-advanced-cqrs-pattern-003",
    "title": "CQRS Pattern (Command Query Responsibility Segregation)",
    "difficulty": "advanced",
    "framework": "NestJS",
    "frameworkIconText": "NestJS",
    "tags": [
      "cqrs",
      "commands",
      "queries",
      "events",
      "architecture",
      "@nestjs/cqrs"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "CQRS is an architectural pattern that separates read (Query) and write (Command) operations for a data store. Commands change state and typically don't return data, while Queries retrieve data and don't change state. This can lead to more scalable and maintainable systems, especially with event sourcing. NestJS provides the `@nestjs/cqrs` module to facilitate this pattern."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// src/commands/impl/create-item.command.ts\n// export class CreateItemCommand { constructor(public readonly name: string, public readonly price: number) {} }\n\n// src/commands/handlers/create-item.handler.ts\n// import { CommandHandler, ICommandHandler } from '@nestjs/cqrs';\n// import { CreateItemCommand } from '../impl/create-item.command';\n// // Assume ItemRepository for DB interaction\n// @CommandHandler(CreateItemCommand)\n// export class CreateItemHandler implements ICommandHandler<CreateItemCommand> {\n//   constructor(private itemRepository: ItemRepository) {}\n//   async execute(command: CreateItemCommand) {\n//     const { name, price } = command;\n//     const item = this.itemRepository.create({ name, price });\n//     await this.itemRepository.save(item);\n//     // Optionally publish an event via EventBus\n//     return item; // Or just void if truly command-like\n//   }\n// }\n\n// src/queries/impl/get-item.query.ts\n// export class GetItemQuery { constructor(public readonly id: string) {} }\n\n// src/queries/handlers/get-item.handler.ts\n// import { QueryHandler, IQueryHandler } from '@nestjs/cqrs';\n// import { GetItemQuery } from '../impl/get-item.query';\n// @QueryHandler(GetItemQuery)\n// export class GetItemHandler implements IQueryHandler<GetItemQuery> {\n//   constructor(private itemRepository: ItemRepository) {}\n//   async execute(query: GetItemQuery) {\n//     return this.itemRepository.findById(query.id);\n//   }\n// }\n\n// In a controller:\n// constructor(private commandBus: CommandBus, private queryBus: QueryBus) {}\n// async createItem(dto: CreateItemDto) { return this.commandBus.execute(new CreateItemCommand(dto.name, dto.price)); }\n// async getItem(id: string) { return this.queryBus.execute(new GetItemQuery(id)); }"
      },
      {
        "type": "explanation",
        "text": "Commands (like `CreateItemCommand`) represent an intent to change state and are handled by `CommandHandlers`. Queries (like `GetItemQuery`) represent a request for data and are handled by `QueryHandlers`. The `CommandBus` and `QueryBus` are used to dispatch these. This separation can allow for different data models or databases for reads and writes."
      }
    ],
    "quiz": {
      "snippet": "// Command: Represents an intent to change state.\n// Query: Represents a request for data, does not change state.",
      "questionText": "What is a core principle of the CQRS (Command Query Responsibility Segregation) pattern?",
      "options": [
        "Combining all read and write operations into a single, optimized model.",
        "Using only GraphQL for data queries and REST for commands.",
        "Separating operations that read data (Queries) from operations that write or mutate data (Commands), potentially using different models or even data stores for each.",
        "Ensuring all database operations are transactional."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "CQRS advocates for separating the model for reading data from the model for updating data. Commands are operations that change state, while Queries are operations that retrieve state without side effects. This separation can lead to simpler models and better performance/scalability for each path."
    }
  },
  {
    "id": "nestjs-advanced-websockets-gateway-004",
    "title": "Real-time Communication with WebSockets (Gateways)",
    "difficulty": "advanced",
    "framework": "NestJS",
    "frameworkIconText": "NestWS",
    "tags": [
      "websockets",
      "gateways",
      "@WebSocketGateway",
      "real-time",
      "socket.io",
      "ws"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "NestJS provides a WebSocket layer that abstracts different WebSocket libraries (like `socket.io` or `ws`). Gateways are classes decorated with `@WebSocketGateway()` that listen for incoming WebSocket messages, handle events, and can emit messages back to clients for real-time communication."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// src/events/events.gateway.ts\n// You'd need to install @nestjs/websockets @nestjs/platform-socket.io (or -ws)\nimport { SubscribeMessage, WebSocketGateway, WebSocketServer, OnGatewayConnection, OnGatewayDisconnect, MessageBody, ConnectedSocket } from '@nestjs/websockets';\nimport { Server, Socket } from 'socket.io'; // Or from 'ws' if using ws adapter\n\n@WebSocketGateway({ cors: { origin: '*' } }) // Configure CORS, port, etc.\nexport class EventsGateway implements OnGatewayConnection, OnGatewayDisconnect {\n  @WebSocketServer() // Injects the native server instance\n  server: Server;\n\n  handleConnection(client: Socket, ...args: any[]) {\n    console.log(`Client connected: ${client.id}`);\n    client.emit('connection_ack', { message: 'Successfully connected!' });\n  }\n\n  handleDisconnect(client: Socket) {\n    console.log(`Client disconnected: ${client.id}`);\n  }\n\n  @SubscribeMessage('messageToServer') // Listens for 'messageToServer' events\n  handleMessage(\n    @MessageBody() data: string, \n    @ConnectedSocket() client: Socket\n  ): void {\n    console.log(`Message from client ${client.id}: ${data}`);\n    // Broadcast to all clients, or specific rooms, or back to sender\n    this.server.emit('messageToClient', `Server received from ${client.id}: ${data}`);\n  }\n\n  // To send a message to a specific client id:\n  // this.server.to(clientId).emit('privateMessage', 'This is for you');\n}"
      },
      {
        "type": "explanation",
        "text": "The `EventsGateway` listens for WebSocket connections. `@SubscribeMessage('eventName')` decorates methods that handle specific incoming messages. `@WebSocketServer()` injects the underlying server instance (e.g., Socket.IO server) to emit messages to clients. `OnGatewayConnection` and `OnGatewayDisconnect` are lifecycle hooks."
      }
    ],
    "quiz": {
      "snippet": "@WebSocketGateway()\nexport class ChatGateway {\n  @WebSocketServer() server: Server;\n\n  @SubscribeMessage('newMessage')\n  handleNewMessage(client: Socket, payload: any) {\n    // this.server.emit('broadcastMessage', payload);\n  }\n}",
      "questionText": "In a NestJS WebSocket Gateway using Socket.IO, what does `this.server.emit('eventName', data)` typically do?",
      "options": [
        "Emits an event only to the client that sent the original message.",
        "Emits an event to all connected clients, including the sender.",
        "Emits an event to all clients except the sender.",
        "Registers a new listener for 'eventName'."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "`this.server.emit()` (where `server` is the Socket.IO server instance) broadcasts an event to all connected clients. To send to all *except* the sender, you'd use `client.broadcast.emit()`. To send only to the sender, you'd use `client.emit()`."
    }
  },
  {
    "id": "nestjs-advanced-dynamic-modules-005",
    "title": "Dynamic Modules (`register`, `forRootAsync`)",
    "difficulty": "advanced",
    "framework": "NestJS",
    "frameworkIconText": "NestJS",
    "tags": [
      "dynamic modules",
      "forRoot",
      "register",
      "forRootAsync",
      "configurable modules",
      "ConfigModule"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Dynamic modules in NestJS allow you to create configurable modules whose providers and configuration depend on options passed during import (e.g., `Module.forRoot(options)` or `Module.register(options)`). This is essential for creating reusable modules that need to be set up differently in various parts of an application or in different applications."
      },
      {
        "type": "code",
        "language": "typescript",
        "code": "// src/database/database.module.ts (Example of a dynamic module)\nimport { Module, DynamicModule, Global } from '@nestjs/common';\n// Assume DbConnection is a class or token for DB connection\n\nexport interface DatabaseModuleOptions {\n  connectionString: string;\n  retryAttempts?: number;\n}\n\n@Global() // Makes providers available globally if desired\n@Module({})\nexport class DatabaseModule {\n  static forRoot(options: DatabaseModuleOptions): DynamicModule {\n    const connectionProvider = {\n      provide: 'DB_CONNECTION', // Or a class like DbConnection\n      useFactory: () => {\n        console.log(`Connecting to DB with: ${options.connectionString}`);\n        // Actual DB connection logic would go here\n        return { /* a mock connection object */ connect: () => `Connected to ${options.connectionString}` };\n      },\n    };\n    return {\n      module: DatabaseModule,\n      providers: [connectionProvider],\n      exports: ['DB_CONNECTION'], // Export the provider\n    };\n  }\n  // Could also have forRootAsync for async configuration (e.g., from ConfigService)\n}\n\n// app.module.ts (Usage)\n// import { DatabaseModule } from './database/database.module';\n// @Module({\n//   imports: [\n//     DatabaseModule.forRoot({ connectionString: process.env.DATABASE_URL || 'default_conn_string' }),\n//     // ... other modules\n//   ],\n// })\n// export class AppModule {}\n\n// my.service.ts (Injecting the dynamic provider)\n// import { Injectable, Inject } from '@nestjs/common';\n// @Injectable()\n// export class MyService {\n//   constructor(@Inject('DB_CONNECTION') private dbConnection: any) {\n//     console.log(this.dbConnection.connect());\n//   }\n// }"
      },
      {
        "type": "explanation",
        "text": "The `DatabaseModule` has a static `forRoot` method that returns a `DynamicModule` object. This object defines the module itself, its providers (which can be configured using the `options` passed to `forRoot`), and its exports. This allows the `DatabaseModule` to be configured with a specific connection string when imported."
      }
    ],
    "quiz": {
      "snippet": "// ConfigurableModule.ts\n// export class ConfigurableModule {\n//   static register(options: MyOptions): DynamicModule {\n//     return {\n//       module: ConfigurableModule,\n//       providers: [{ provide: 'CONFIG_OPTIONS', useValue: options }],\n//       exports: ['CONFIG_OPTIONS']\n//     };\n//   }\n// }\n// App.module.ts\n// imports: [ConfigurableModule.register({ apiKey: '123' })]",
      "questionText": "What is a primary benefit of using dynamic modules in NestJS?",
      "options": [
        "To automatically generate REST API endpoints for all providers.",
        "To allow a module to be configured with options when it's imported, making it more reusable and flexible.",
        "To enforce that all modules in an application are singletons.",
        "To provide a way to write modules using only JavaScript instead of TypeScript."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "Dynamic modules (using static methods like `forRoot()` or `register()`) allow you to create modules that can be configured with specific options when they are imported into other modules. This is crucial for creating reusable modules (like a database module or a configuration module) that need to behave differently based on the provided options."
    }
  },
  {
    "id": "express-advanced-auth-middleware-jwt-001",
    "title": "Custom Authentication Middleware (e.g., JWT)",
    "difficulty": "advanced",
    "framework": "Express.js",
    "frameworkIconText": "Express",
    "tags": [
      "express",
      "middleware",
      "authentication",
      "jwt",
      "security",
      "authorization"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "For secure applications, you often need to authenticate users. Middleware can inspect request headers (e.g., for a JSON Web Token - JWT), verify the token, and attach user information to the `req` object for subsequent route handlers or guards."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// auth.middleware.js (simplified JWT example - needs 'jsonwebtoken' package: npm install jsonwebtoken)\nconst jwt = require('jsonwebtoken');\nconst SECRET_KEY = process.env.JWT_SECRET || 'your-very-secret-key'; // Use environment variable in real apps\n\nfunction authenticateToken(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN_STRING\n\n  if (token == null) return res.sendStatus(401); // Unauthorized if no token\n\n  jwt.verify(token, SECRET_KEY, (err, user) => {\n    if (err) {\n      console.error('JWT verification error:', err.message);\n      return res.sendStatus(403); // Forbidden if token is invalid/expired\n    }\n    req.user = user; // Attach user payload to request object\n    next(); // Proceed to the next middleware or route handler\n  });\n}\n\n// server.js\n// const express = require('express');\n// const app = express();\n// // app.use('/protected-route', authenticateToken); // Apply to specific routes or globally\n// \n// app.get('/protected-data', authenticateToken, (req, res) => {\n//   // req.user is available here if token was valid\n//   res.json({ message: 'This is protected data', user: req.user });\n// });\n// \n// app.listen(3000);"
      },
      {
        "type": "explanation",
        "text": "The `authenticateToken` middleware extracts a JWT from the `Authorization` header, verifies it using a secret key, and if valid, attaches the decoded user payload to `req.user`. If the token is missing or invalid, it sends an appropriate error response. This middleware can be applied globally or to specific routes."
      }
    ],
    "quiz": {
      "snippet": "// function isAdmin(req, res, next) {\n//   if (req.user && req.user.role === 'admin') {\n//     next();\n//   } else {\n//     res.status(403).send('Forbidden: Admins only');\n//   }\n// }\n// app.get('/admin/panel', authenticateToken, isAdmin, (req, res) => { ... });",
      "questionText": "If an Express middleware for authentication successfully verifies a user and calls `next()`, what is its typical next step if it also needs to attach user data to the request object for subsequent handlers?",
      "options": [
        "It sends a 200 OK response immediately.",
        "It stores the user data in a global variable.",
        "It typically attaches the user data as a property to the `req` object (e.g., `req.user = userData;`).",
        "It redirects the user to their profile page."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "A common pattern for authentication middleware is to verify the user's credentials (e.g., from a token) and then attach the authenticated user's information to the `req` object (e.g., `req.user`). This makes the user data easily accessible to subsequent route handlers and authorization middleware."
    }
  },
  {
    "id": "express-advanced-file-uploads-multer-002",
    "title": "Handling File Uploads with Multer",
    "difficulty": "advanced",
    "framework": "Express.js",
    "frameworkIconText": "Express",
    "tags": [
      "express",
      "file uploads",
      "multer",
      "middleware",
      "multipart/form-data"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Multer is a popular middleware for handling `multipart/form-data`, which is primarily used for uploading files. It makes uploaded files available in `req.file` (for single file) or `req.files` (for multiple files)."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// server.js (needs 'multer' package: npm install multer)\nconst express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst app = express();\n\n// Configure Multer storage (e.g., save to disk)\nconst storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, 'uploads/'); // Ensure 'uploads/' directory exists\n  },\n  filename: function (req, file, cb) {\n    // cb(null, file.fieldname + '-' + Date.now() + path.extname(file.originalname));\n    cb(null, `${Date.now()}-${file.originalname.replace(/\\s+/g, '_')}`);\n  }\n});\nconst upload = multer({ storage: storage, limits: { fileSize: 1024 * 1024 * 5 } }); // 5MB limit\n\n// Route to handle single file upload (input field name 'myImage')\napp.post('/upload-profile-pic', upload.single('myImage'), (req, res, next) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n  console.log('File uploaded:', req.file);\n  res.send(`File ${req.file.filename} uploaded successfully! Path: ${req.file.path}`);\n}, (error, req, res, next) => { // Multer error handling\n  if (error instanceof multer.MulterError) {\n    return res.status(400).send(`Multer error: ${error.message}`);\n  }\n  res.status(500).send(`Something else broke: ${error.message}`);\n});\n\n// Route to handle multiple files (input field name 'myGallery', max 5 files)\n// app.post('/upload-gallery', upload.array('myGallery', 5), (req, res) => { ... });\n\napp.listen(3000);"
      },
      {
        "type": "explanation",
        "text": "Multer is configured with storage options (here, `diskStorage` to save files) and limits. `upload.single('fieldName')` is middleware that processes a single file upload from an input field named 'fieldName'. Information about the uploaded file is then available in `req.file`."
      }
    ],
    "quiz": {
      "snippet": "// const upload = multer({ dest: 'temp_uploads/' });\n// app.post('/submit-form', upload.single('userFile'), (req, res) => {\n//   // Where would you typically find information about the uploaded file?\n// });",
      "questionText": "When using Multer middleware configured with `upload.single('userFile')` to handle a file upload, where is the information about the uploaded file typically made available in the route handler?",
      "options": [
        "req.body.userFile",
        "req.params.userFile",
        "req.file",
        "req.files[0]"
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "If `upload.single('fieldName')` is used, Multer processes the uploaded file associated with that field name and makes its details (like path, filename, size, etc.) available on the `req.file` object."
    }
  },
  {
    "id": "express-advanced-security-headers-helmet-003",
    "title": "Enhancing Security with Helmet.js",
    "difficulty": "advanced",
    "framework": "Express.js",
    "frameworkIconText": "Express",
    "tags": [
      "express",
      "security",
      "helmet",
      "http headers",
      "xss",
      "clickjacking"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Helmet.js is a collection of middleware functions that help secure Express apps by setting various HTTP headers. These headers can protect against common web vulnerabilities like Cross-Site Scripting (XSS), clickjacking, and others."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// server.js (needs 'helmet' package: npm install helmet)\nconst express = require('express');\nconst helmet = require('helmet');\nconst app = express();\n\n// Use Helmet - sets various security-related HTTP headers\n// Includes middlewares like: csp, hidePoweredBy, hsts, ieNoOpen, noSniff, xssFilter etc.\napp.use(helmet());\n\n// You can also configure individual middlewares if needed:\n// app.use(helmet.contentSecurityPolicy({\n//   directives: {\n//     defaultSrc: [\"'self'\"],\n//     scriptSrc: [\"'self'\", \"'unsafe-inline'\", \"trusted-cdn.com\"],\n//   }\n// }));\n\napp.get('/', (req, res) => {\n  res.send('Hello with enhanced security headers!');\n});\n\napp.listen(3000);"
      },
      {
        "type": "explanation",
        "text": "`app.use(helmet())` applies a suite of security-focused HTTP header middleware. For example, `X-Content-Type-Options: nosniff` prevents browsers from MIME-sniffing a response away from the declared content-type. `X-XSS-Protection` enables XSS filtering. `Content-Security-Policy` can be configured to restrict sources for scripts, styles, etc."
      }
    ],
    "quiz": {
      "snippet": "// app.use(helmet());\n// What is a primary goal of using the Helmet.js middleware in an Express application?",
      "questionText": "What is a key benefit of using Helmet.js in an Express application?",
      "options": [
        "To compress HTTP responses using Gzip.",
        "To handle file uploads securely.",
        "To set various HTTP headers that help protect the application against common web vulnerabilities like XSS and clickjacking.",
        "To provide a session management solution."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Helmet.js helps secure Express applications by setting a variety of HTTP headers that mitigate common security risks. These headers instruct the browser on how to behave, reducing attack vectors for things like XSS, clickjacking, and insecure requests."
    }
  },
  {
    "id": "express-advanced-async-error-handling-004",
    "title": "Handling Errors in Asynchronous Route Handlers",
    "difficulty": "advanced",
    "framework": "Express.js",
    "frameworkIconText": "Express",
    "tags": [
      "express",
      "async",
      "await",
      "error handling",
      "promises",
      "next(err)"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "By default, Express 5+ automatically catches errors thrown in `async` route handlers and passes them to the error-handling middleware. For Express 4 and older, or for errors in Promise chains without `async/await`, you must explicitly pass errors to `next()`."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "const express = require('express');\nconst app = express();\n\n// Simulates an async operation that might fail\nasync function fetchDataFromDb(id) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (id === 'valid') {\n        resolve({ data: 'Some data' });\n      } else if (id === 'error') {\n        reject(new Error('Database query failed!'));\n      } else {\n        const err = new Error('Resource not found');\n        err.status = 404;\n        reject(err);\n      }\n    }, 500);\n  });\n}\n\n// Async route handler (Express 5+ handles unhandled promise rejections automatically)\napp.get('/data/:id', async (req, res, next) => {\n  try {\n    const result = await fetchDataFromDb(req.params.id);\n    res.json(result);\n  } catch (err) {\n    next(err); // Explicitly pass error to error handler middleware\n  }\n});\n\n// Error handling middleware (defined last)\napp.use((err, req, res, next) => {\n  console.error('Error caught:', err.message);\n  res.status(err.status || 500).json({ error: err.message || 'Something went wrong!' });\n});\n\napp.listen(3000);"
      },
      {
        "type": "explanation",
        "text": "In the `async` route handler, a `try...catch` block is used. If `fetchDataFromDb` rejects its promise (throws an error), the `catch` block catches it and explicitly passes it to `next(err)`. This ensures it's handled by the centralized error middleware. Express 5 improves this by auto-catching rejections from `async` handlers."
      }
    ],
    "quiz": {
      "snippet": "app.get('/items', async (req, res, next) => {\n  try {\n    // const items = await db.query('SELECT ...');\n    // if (!items) throw new Error('Not found'); \n    // res.json(items);\n  } catch (error) {\n    // How to pass 'error' to Express's error handling middleware?\n  }\n});",
      "questionText": "Inside an `async` route handler in Express, if an `await`ed promise rejects or an error is thrown, how should you typically ensure it's processed by Express's error handling middleware?",
      "options": [
        "By returning `res.status(500).send(error)` directly.",
        "The error is automatically handled and logged by Express without any extra code.",
        "By calling `next(error)` within a `catch` block.",
        "By re-throwing the error outside the `try...catch` block."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "To delegate error handling to Express's centralized error middleware from an `async` route handler, you should wrap your asynchronous operations in a `try...catch` block and call `next(error)` within the `catch` block. (Note: Express 5+ has improved automatic error catching for `async` handlers, but explicit `next(err)` is still robust)."
    }
  },
  {
    "id": "express-advanced-response-streaming-005",
    "title": "Streaming Responses for Large Data",
    "difficulty": "advanced",
    "framework": "Express.js",
    "frameworkIconText": "Express",
    "tags": [
      "express",
      "streams",
      "response stream",
      "large data",
      "performance",
      "fs.createReadStream"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "For sending large amounts of data (like large files or dynamically generated content), streaming the response is more memory-efficient than buffering the entire content in memory before sending. You can pipe a Readable stream directly to the Express response object (`res`)."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "const express = require('express');\nconst fs = require('fs');\nconst path = require('path');\nconst app = express();\n\napp.get('/download-large-file', (req, res) => {\n  const filePath = path.join(__dirname, 'public', 'large-video.mp4'); // Assume this file exists\n  \n  // Check if file exists (basic check)\n  if (!fs.existsSync(filePath)) {\n    return res.status(404).send('File not found.');\n  }\n\n  // Set appropriate headers for download and content type\n  res.setHeader('Content-Disposition', 'attachment; filename=\"large-video.mp4\"');\n  res.setHeader('Content-Type', 'video/mp4');\n\n  const fileStream = fs.createReadStream(filePath);\n  \n  // Pipe the file stream to the response object\n  fileStream.pipe(res);\n\n  fileStream.on('error', (err) => {\n    console.error('Error streaming file:', err);\n    // If headers haven't been sent yet, send an error status\n    if (!res.headersSent) {\n      res.status(500).send('Error streaming file.');\n    }\n    // Important: ensure stream is destroyed to prevent leaks if error occurs mid-stream\n    fileStream.destroy(); \n  });\n\n  res.on('finish', () => {\n    console.log('File successfully streamed.');\n  });\n});\n\napp.listen(3000);"
      },
      {
        "type": "explanation",
        "text": "`fs.createReadStream()` creates a readable stream for the file. This stream is then `pipe()`d to the Express response object (`res`), which is also a Writable stream. This sends the file data in chunks without loading it all into memory. Setting correct `Content-Disposition` and `Content-Type` headers is important."
      }
    ],
    "quiz": {
      "snippet": "// const fileStream = fs.createReadStream('big-report.csv');\n// res.setHeader('Content-Type', 'text/csv');\n// fileStream.pipe(res);",
      "questionText": "What is a primary advantage of piping a readable stream (e.g., from a large file) directly to the Express response object (`res`)?",
      "options": [
        "It allows Express to automatically compress the data using Brotli.",
        "It significantly reduces server memory usage by sending data in chunks instead of loading the entire content into memory first.",
        "It encrypts the data before sending it to the client.",
        "It makes the HTTP request synchronous."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "Piping a readable stream to the response object allows Node.js and Express to send data to the client in chunks as it's read from the source (e.g., a file). This is highly memory efficient for large data, as it avoids buffering the entire response body in server memory."
    }
  },
  {
    "id": "tailwind-advanced-custom-plugin-001",
    "title": "Creating a Custom Tailwind Plugin (with Utilities & Components)",
    "difficulty": "advanced",
    "framework": "Tailwind CSS",
    "frameworkIconText": "TW",
    "tags": [
      "tailwind",
      "plugins",
      "custom utilities",
      "custom components",
      "plugin API"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Tailwind's plugin system allows you to register new styles, utilities, components, or variants using JavaScript. This is powerful for encapsulating complex or repeated patterns, or for adding new design system primitives not covered by core utilities."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// tailwind.config.js\nconst plugin = require('tailwindcss/plugin');\n\nmodule.exports = {\n  content: [/* ... */],\n  theme: {\n    extend: {\n      // Define theme values that your plugin might use\n      skew: {\n        '15': '15deg',\n        '-15': '-15deg',\n      }\n    }\n  },\n  plugins: [\n    plugin(function({ addUtilities, addComponents, theme, e }) {\n      // Add new utility classes\n      const newUtilities = {\n        '.skew-15': {\n          transform: `skewY(-${theme('skew.15')})`,\n        },\n        '.skew-n-15': {\n          transform: `skewY(${theme('skew.15')})`,\n        },\n      };\n      addUtilities(newUtilities, ['responsive', 'hover']);\n\n      // Add new component classes\n      addComponents({\n        '.card-fancy': {\n          backgroundColor: theme('colors.white'),\n          borderRadius: theme('borderRadius.lg'),\n          padding: theme('spacing.6'),\n          boxShadow: theme('boxShadow.xl'),\n          '&:hover': { // Nested CSS for hover state\n            boxShadow: theme('boxShadow.2xl'),\n          }\n        },\n        '.btn-custom-gradient': {\n          backgroundImage: `linear-gradient(to right, ${theme('colors.pink.500')}, ${theme('colors.purple.600')})`,\n          // ... other button styles\n        }\n      });\n    })\n  ]\n};\n\n// HTML Usage:\n// <div class=\"skew-15 hover:skew-n-15\">Skewed Text</div>\n// <div class=\"card-fancy\">Fancy Card Content</div>"
      },
      {
        "type": "explanation",
        "text": "The plugin function receives helpers like `addUtilities` (to register new utility classes like `.skew-15`), `addComponents` (to register more complex component classes like `.card-fancy`), `theme` (to access theme values), and `e` (to escape class names for variants). This allows deep extension of Tailwind's capabilities."
      }
    ],
    "quiz": {
      "snippet": "// tailwind.config.js (inside a plugin function)\n// addUtilities({\n//   '.custom-rotate-45': { transform: 'rotate(45deg)' }\n// }, ['responsive', 'focus']);",
      "questionText": "What is the primary purpose of the `addUtilities` function provided to a Tailwind CSS plugin's setup function?",
      "options": [
        "To add new JavaScript helper functions to the build process.",
        "To register new, low-level utility classes that can be used in HTML, optionally with variants.",
        "To define complex, multi-class component styles.",
        "To extend Tailwind's default color palette."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "The `addUtilities` function allows a plugin to register new utility classes (e.g., `.custom-rotate-45`). These utilities can then be applied directly to HTML elements, and you can specify which variants (like responsive or state variants) should be generated for them."
    }
  },
  {
    "id": "tailwind-advanced-jit-arbitrary-values-002",
    "title": "JIT Engine: Arbitrary Values and Advanced Usage",
    "difficulty": "advanced",
    "framework": "Tailwind CSS",
    "frameworkIconText": "TW",
    "tags": [
      "tailwind",
      "jit engine",
      "arbitrary values",
      "performance",
      "on-the-fly generation"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Tailwind's JIT (Just-In-Time) engine, which is standard in v3+, generates styles on-demand as it scans your template files. This allows for features like arbitrary value support, where you can use specific, one-off values directly in your class names without pre-configuring them."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<div class=\"bg-[#1DA1F2] text-[17px] p-[13px] m-[7px_11px] lg:top-[calc(100vh-50px)]\">\n  <!-- \n    bg-[#1DA1F2]: Arbitrary background color (hex).\n    text-[17px]: Arbitrary font size.\n    p-[13px]: Arbitrary padding.\n    m-[7px_11px]: Arbitrary margin (top/bottom 7px, left/right 11px).\n    lg:top-[calc(100vh-50px)]: Arbitrary top position with calc() on large screens.\n  -->\n  Content with very specific styling.\n</div>\n\n<div class=\"grid grid-cols-[auto_1fr_minmax(0,200px)] gap-[テーマ('spacing.3')]\">\n  <!-- \n    grid-cols-[auto_1fr_minmax(0,200px)]: Arbitrary grid column template.\n    gap-[テーマ('spacing.3')]: Arbitrary gap using a theme value (conceptual, direct theme access in class needs plugin or specific syntax).\n    Correct arbitrary theme access: gap-[var(--spacing-3)] if CSS vars are set from theme, or directly gap-[0.75rem].\n    Or, for direct theme access in some contexts (like config): theme('spacing.3')\n    The class should be: gap-[0.75rem] (if spacing.3 is 0.75rem)\n  -->\n  <span>Sidebar</span>\n  <span>Main</span>\n  <span>Aside</span>\n</div>"
      },
      {
        "type": "explanation",
        "text": "Square bracket notation `[...]` allows you to use arbitrary values for many Tailwind utilities (colors, spacing, font sizes, grid templates, etc.). This provides immense flexibility without bloating your `tailwind.config.js` for every minor variation. Be mindful that complex arbitrary values, especially those with spaces or special characters, might need quotes or specific formatting if used within CSS-in-JS or certain templating languages."
      }
    ],
    "quiz": {
      "snippet": "<div class=\"w-[33.33%] h-[calc(100%-2rem)] bg-[hsl(210,50%,50%)]\">\n  Dynamic Box\n</div>",
      "questionText": "What does the square bracket notation (e.g., `w-[33.33%]`) enable in Tailwind CSS (v3+ with JIT)?",
      "options": [
        "It defines a custom CSS variable.",
        "It allows the use of arbitrary, one-off values directly in utility classes without pre-defining them in the theme configuration.",
        "It applies a CSS `!important` flag to the utility.",
        "It groups multiple utility classes together."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "The square bracket notation in Tailwind's JIT mode allows you to use arbitrary values for utilities. For example, `w-[33.33%]` generates `width: 33.33%;` on the fly, even if '33.33%' isn't explicitly defined in your theme's width scale."
    }
  },
  {
    "id": "tailwind-advanced-performance-purging-optimizing-003",
    "title": "Performance: Purging, Layering, and Optimizing CSS Output",
    "difficulty": "advanced",
    "framework": "Tailwind CSS",
    "frameworkIconText": "TW",
    "tags": [
      "tailwind",
      "performance",
      "purging",
      "css layers",
      "jit",
      "optimization"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Tailwind's JIT engine inherently optimizes by only generating CSS for classes actually used in your project. However, understanding how to configure `content` paths correctly is crucial. Additionally, using CSS layers (`@layer base, components, utilities`) can help manage CSS specificity and overrides when integrating with other CSS or component libraries."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// tailwind.config.js\nmodule.exports = {\n  content: [\n    './src/**/*.html',\n    './src/**/*.vue',\n    './src/**/*.jsx',\n    './src/**/*.js',\n    './src/**/*.svelte',\n    // Add all file types and paths where you use Tailwind classes\n  ],\n  // mode: 'jit', // JIT is default in Tailwind v3\n  theme: { extend: {} },\n  plugins: [],\n};\n\n// main.css (or equivalent)\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n// Using layers for custom styles to ensure proper order and override behavior\n// @layer base {\n//   h1 { @apply text-2xl font-bold; }\n// }\n// @layer components {\n//   .custom-card { @apply bg-white p-4 rounded shadow; }\n// }\n// @layer utilities {\n//   .text-shadow-custom { text-shadow: 1px 1px 2px black; }\n// }"
      },
      {
        "type": "explanation",
        "text": "The `content` array in `tailwind.config.js` must accurately list all files that contain Tailwind classes so the JIT engine can scan them. Using `@layer` directives in your CSS helps control the cascade, ensuring Tailwind's base styles, component classes, and utilities are applied in the intended order, and custom styles can be layered appropriately."
      }
    ],
    "quiz": {
      "snippet": "// tailwind.config.js\n// content: ['./app/**/*.{js,ts,jsx,tsx}', './components/**/*.{js,ts,jsx,tsx}']\n\n// main.css\n// @tailwind base;\n// @tailwind components;\n// @tailwind utilities;",
      "questionText": "In Tailwind CSS v3 (with JIT), what is the primary role of the `content` property in `tailwind.config.js`?",
      "options": [
        "To define the static HTML content for the homepage.",
        "To specify the file paths that Tailwind should scan to discover which utility classes are being used, so it can generate only the necessary CSS.",
        "To list external CSS libraries to be imported.",
        "To configure the default font families and color palettes."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "The `content` configuration in `tailwind.config.js` tells Tailwind's JIT engine which files to scan for class names. Tailwind then generates CSS only for the classes found in these files, resulting in a highly optimized, small final CSS bundle."
    }
  },
  {
    "id": "tailwind-advanced-variant-grouping-arbitrary-variants-004",
    "title": "Advanced Variants: Grouping & Arbitrary Variants",
    "difficulty": "advanced",
    "framework": "Tailwind CSS",
    "frameworkIconText": "TW",
    "tags": [
      "tailwind",
      "variants",
      "group-hover",
      "peer-checked",
      "arbitrary variants",
      "state management"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Tailwind provides powerful state variants like `hover:`, `focus:`, `disabled:`, etc. For more complex interactions, `group-*` and `peer-*` variants allow styling based on the state of a parent or sibling. Arbitrary variants allow you to create highly specific conditional styles based on attribute selectors or other CSS pseudo-classes/elements."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<!-- Group Hover Example -->\n<a href=\"#\" class=\"group block max-w-xs mx-auto rounded-lg p-6 bg-white ring-1 ring-slate-900/5 shadow-lg space-y-3 hover:bg-sky-500 hover:ring-sky-500\">\n  <div class=\"flex items-center space-x-3\">\n    <svg class=\"h-6 w-6 stroke-sky-500 group-hover:stroke-white\" fill=\"none\" viewBox=\"0 0 24 24\"><!-- ... icon --></svg>\n    <h3 class=\"text-slate-900 group-hover:text-white text-sm font-semibold\">New Project</h3>\n  </div>\n  <p class=\"text-slate-500 group-hover:text-white text-sm\">Create a new project from a variety of starting templates.</p>\n</a>\n\n<!-- Peer Checked Example (e.g., styling a label based on checkbox state) -->\n<label class=\"block\">\n  <input type=\"checkbox\" class=\"peer sr-only\" />\n  <span class=\"block p-2 border border-gray-300 rounded peer-checked:bg-blue-500 peer-checked:text-white\">\n    Toggle Me\n  </span>\n</label>\n\n<!-- Arbitrary Variant Example -->\n<div class=\"[data-theme='dark']_bg-gray-900 [data-theme='dark']_text-white p-4\">\n  This styles based on a data attribute on an ancestor.\n</div>\n<div class=\"[&_p]:mt-2 first-of-type:text-lg\">\n  <p>Paragraph 1</p>\n  <p>Paragraph 2 (will have mt-2)</p>\n</div>"
      },
      {
        "type": "explanation",
        "text": "Add `group` to a parent to use `group-hover:`, `group-focus:` etc. on children. Add `peer` to an element to use `peer-checked:`, `peer-focus:` etc. on its subsequent siblings. Arbitrary variants `[selector]_utility` let you apply utilities when a complex CSS selector (like `[data-theme='dark']` or `&_p` for child paragraphs) matches."
      }
    ],
    "quiz": {
      "snippet": "<div class=\"group\">\n  <p class=\"text-gray-700 group-hover:text-blue-500\">Hover the div to change my color.</p>\n</div>",
      "questionText": "What does the `group-hover:text-blue-500` class on the `<p>` tag do?",
      "options": [
        "Changes the paragraph text to blue when the paragraph itself is hovered.",
        "Changes the paragraph text to blue when any element with the class `group` on the page is hovered.",
        "Changes the paragraph text to blue when its direct parent (or an ancestor marked with the `group` class) is hovered.",
        "Groups this paragraph with other elements for layout purposes."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "The `group` class is added to a parent or ancestor element. Then, `group-hover:` (or other `group-*` variants) can be used on child elements to style them based on the state of that marked ancestor group. So, when the parent `div` is hovered, the paragraph text becomes blue."
    }
  },
  {
    "id": "tailwind-advanced-custom-font-metrics-005",
    "title": "Fine-tuning Typography & Custom Font Metrics",
    "difficulty": "advanced",
    "framework": "Tailwind CSS",
    "frameworkIconText": "TW",
    "tags": [
      "tailwind",
      "typography",
      "font metrics",
      "line height",
      "capsize",
      "theme customization"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "While Tailwind's typography utilities are extensive, achieving perfect vertical rhythm and baseline alignment with custom fonts sometimes requires fine-tuning font metrics. This can involve adjusting line heights, letter spacing, or even using plugins like `@tailwindcss/typography` with its `prose` classes, or more advanced techniques for cap height based text trimming."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// tailwind.config.js (Conceptual - Capsize integration is more complex)\n// For precise control, you might integrate a library like Capsize.\n// This example shows basic line-height and letter-spacing customization.\nmodule.exports = {\n  theme: {\n    extend: {\n      fontFamily: {\n        'sans': ['Inter var', 'system-ui'],\n      },\n      lineHeight: {\n        'extra-tight': '1.1',\n        '12': '3rem', // For specific use cases\n      },\n      letterSpacing: {\n        'tighter': '-.05em',\n        'tight': '-.025em',\n        'normal': '0',\n        'wide': '.025em',\n        'wider': '.05em',\n        'widest': '.1em',\n      }\n    }\n  },\n  plugins: [\n    // require('@tailwindcss/typography'), // For .prose styling\n    // Potentially a custom plugin for Capsize-like text trimming\n    // plugin(function({ addUtilities, theme }) { ... advanced font metric utilities ... })\n  ]\n}\n\n// HTML Usage:\n// <h1 class=\"font-sans text-4xl leading-extra-tight tracking-tight\">Precise Heading</h1>\n// <p class=\"font-sans text-base leading-relaxed tracking-normal\">Body text with good rhythm.</p>"
      },
      {
        "type": "explanation",
        "text": "You can customize `lineHeight` and `letterSpacing` in `tailwind.config.js`. For pixel-perfect typography aligning to cap heights and baselines, especially with diverse custom fonts, developers sometimes create custom utilities or plugins, potentially inspired by libraries like Capsize, to trim leading/trailing space from text elements."
      },
      {
        "type": "tip",
        "text": "The `@tailwindcss/typography` plugin is excellent for styling blocks of HTML content (like from Markdown) with sensible typographic defaults, and it can also be customized."
      }
    ],
    "quiz": {
      "snippet": "// tailwind.config.js\n// theme: {\n//   extend: {\n//     lineHeight: { 'custom-loose': '2.5' }\n//   }\n// }",
      "questionText": "If you want to achieve very precise vertical alignment of text based on its cap height and baseline, beyond standard line-height adjustments, what might be an advanced approach with Tailwind?",
      "options": [
        "Only using `leading-none` on all text elements.",
        "Manually adjusting `margin-top` and `margin-bottom` on every text element with arbitrary values.",
        "Creating custom utility classes or a plugin, possibly inspired by font metric libraries like Capsize, to trim space above cap height and below baseline.",
        "Setting a global `font-size` of `1px`."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "For highly precise typographic control based on font metrics (like cap height and baseline), standard line-height utilities might not be enough. Advanced techniques involve calculating and trimming the extra space around text, often encapsulated in custom Tailwind utilities or plugins, sometimes using concepts from libraries like Capsize."
    }
  },
  {
    "id": "bootstrap-advanced-custom-sass-001",
    "title": "Customizing Bootstrap with Sass",
    "difficulty": "advanced",
    "framework": "Bootstrap",
    "frameworkIconText": "BS",
    "tags": [
      "bootstrap",
      "sass",
      "customization",
      "theming",
      "scss",
      "build process"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "For deep customization, Bootstrap is built with Sass. You can override default Sass variables (colors, spacing, typography, etc.), import only the parts of Bootstrap you need, or add your own custom styles by importing Bootstrap's source files into your Sass workflow. This gives much more control than just overriding CSS."
      },
      {
        "type": "code",
        "language": "scss",
        "code": "// custom.scss (Your main Sass file)\n\n// 1. Override Bootstrap's default variables (BEFORE importing Bootstrap functions & variables)\n$primary: #5252d4; // Change primary color\n$font-family-sans-serif: \"Roboto\", sans-serif; // Change default sans-serif font\n$border-radius: .5rem; // Increase default border radius\n\n// 2. Include Bootstrap's functions and variables (required for compilation)\n@import \"~bootstrap/scss/functions\";\n@import \"~bootstrap/scss/variables\";\n\n// 3. Optionally, create custom color maps or modify existing ones\n$custom-colors: (\n  \"custom-purple\": #6f42c1\n);\n$theme-colors: map-merge($theme-colors, $custom-colors);\n\n// 4. Import the rest of Bootstrap (or only the parts you need)\n@import \"~bootstrap/scss/bootstrap\"; // Imports everything\n// OR to import only specific parts:\n// @import \"~bootstrap/scss/root\";\n// @import \"~bootstrap/scss/reboot\";\n// @import \"~bootstrap/scss/containers\";\n// @import \"~bootstrap/scss/grid\";\n// @import \"~bootstrap/scss/buttons\";\n// ...etc.\n\n// 5. Add your own custom SCSS rules\n.my-custom-component {\n  background-color: $primary;\n  padding: $spacer * 2; // Use Bootstrap's $spacer variable\n  color: color-contrast($primary);\n}"
      },
      {
        "type": "explanation",
        "text": "By importing Bootstrap's Sass source (`~bootstrap/scss/...`), you can override its variables before they are used to generate CSS. This allows for a custom-tailored version of Bootstrap. `$theme-colors` can be merged with custom colors to generate new `.btn-custom-purple`, `.text-custom-purple` utilities, etc. You need a Sass compiler in your build process."
      }
    ],
    "quiz": {
      "snippet": "// custom.scss\n// $body-bg: #f0f2f5;\n// $border-width: 2px;\n// @import \"~bootstrap/scss/bootstrap\";",
      "questionText": "What is a key advantage of customizing Bootstrap using its Sass source files instead of just overriding its compiled CSS?",
      "options": [
        "It results in smaller JavaScript bundle sizes.",
        "It allows you to change HTML structure generated by Bootstrap components.",
        "You can modify Bootstrap's core Sass variables (like colors, spacing, fonts) to generate a custom version of Bootstrap, and you can choose to import only the parts you need, potentially reducing final CSS size.",
        "It's the only way to make Bootstrap responsive."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Customizing Bootstrap via Sass allows you to directly modify its source variables before compilation. This means you can change fundamental aspects like the primary color pallet, default font, spacing units, etc., and have these changes reflected throughout all Bootstrap components and utilities. You can also selectively import Bootstrap parts to optimize the final CSS output."
    }
  },
  {
    "id": "bootstrap-advanced-offcanvas-complex-002",
    "title": "Advanced Offcanvas Usage (e.g., with Forms, different placements)",
    "difficulty": "advanced",
    "framework": "Bootstrap",
    "frameworkIconText": "BS",
    "tags": [
      "bootstrap",
      "offcanvas",
      "sidebar",
      "forms",
      "javascript component",
      "placement"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Bootstrap's offcanvas component can be used for more than just simple navigation. It can house forms, detailed information, or act as a settings panel. You can control its placement (start, end, top, bottom) and behavior (backdrop, scrolling)."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<button class=\"btn btn-primary\" type=\"button\" data-bs-toggle=\"offcanvas\" data-bs-target=\"#offcanvasSettings\" aria-controls=\"offcanvasSettings\">\n  Open Settings Panel (from right)\n</button>\n\n<button class=\"btn btn-secondary\" type=\"button\" data-bs-toggle=\"offcanvas\" data-bs-target=\"#offcanvasBottomForm\" aria-controls=\"offcanvasBottomForm\">\n  Feedback Form (from bottom)\n</button>\n\n<!-- Offcanvas Settings Panel (from right/end) -->\n<div class=\"offcanvas offcanvas-end\" tabindex=\"-1\" id=\"offcanvasSettings\" aria-labelledby=\"offcanvasSettingsLabel\">\n  <div class=\"offcanvas-header\">\n    <h5 class=\"offcanvas-title\" id=\"offcanvasSettingsLabel\">Settings</h5>\n    <button type=\"button\" class=\"btn-close text-reset\" data-bs-dismiss=\"offcanvas\" aria-label=\"Close\"></button>\n  </div>\n  <div class=\"offcanvas-body\">\n    <p>Configure your application settings here...</p>\n    <div class=\"form-check form-switch\">\n      <input class=\"form-check-input\" type=\"checkbox\" role=\"switch\" id=\"flexSwitchCheckDefault\">\n      <label class=\"form-check-label\" for=\"flexSwitchCheckDefault\">Enable Dark Mode</label>\n    </div>\n  </div>\n</div>\n\n<!-- Offcanvas Feedback Form (from bottom) -->\n<div class=\"offcanvas offcanvas-bottom\" tabindex=\"-1\" id=\"offcanvasBottomForm\" aria-labelledby=\"offcanvasBottomLabel\" style=\"height: 50vh;\"> \n  <div class=\"offcanvas-header\">\n    <h5 class=\"offcanvas-title\" id=\"offcanvasBottomLabel\">Submit Feedback</h5>\n    <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"offcanvas\" aria-label=\"Close\"></button>\n  </div>\n  <div class=\"offcanvas-body\">\n    <form>\n      <div class=\"mb-3\">\n        <label for=\"feedbackText\" class=\"form-label\">Your Feedback</label>\n        <textarea class=\"form-control\" id=\"feedbackText\" rows=\"3\"></textarea>\n      </div>\n      <button type=\"submit\" class=\"btn btn-success\">Send</button>\n    </form>\n  </div>\n</div>"
      },
      {
        "type": "explanation",
        "text": "`offcanvas-end` makes the panel slide from the right. `offcanvas-bottom` makes it slide from the bottom. You can set a custom height for `offcanvas-bottom` or `offcanvas-top`. The `data-bs-scroll` (to allow body scroll) and `data-bs-backdrop` (to enable/disable static backdrop) attributes on the trigger or offcanvas element provide further control."
      }
    ],
    "quiz": {
      "snippet": "<button data-bs-toggle=\"offcanvas\" data-bs-target=\"#mySidebar\"></button>\n<div class=\"offcanvas offcanvas-start\" id=\"mySidebar\">...</div>",
      "questionText": "Which class is used to make a Bootstrap offcanvas panel slide in from the left side of the screen?",
      "options": [
        "offcanvas-left",
        "offcanvas-begin",
        "offcanvas-start",
        "offcanvas-top"
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "The `offcanvas-start` class positions the offcanvas panel to slide in from the left (start in LTR languages). Similarly, `offcanvas-end` is for the right, `offcanvas-top` for the top, and `offcanvas-bottom` for the bottom."
    }
  },
  {
    "id": "bootstrap-advanced-utilities-api-003",
    "title": "Using Bootstrap's JavaScript Utilities API (Conceptual)",
    "difficulty": "advanced",
    "framework": "Bootstrap",
    "frameworkIconText": "BS",
    "tags": [
      "bootstrap",
      "javascript api",
      "utilities",
      "sass api",
      "css variables"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Beyond CSS classes, Bootstrap 5 exposes some of its functionality through a JavaScript Utilities API and extensively uses CSS Variables. This allows for more dynamic and programmatic interaction with Bootstrap's theming and utilities, though direct use of the JS Utilities API by end-users is less common than using Sass variables or CSS overrides."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Example: Accessing Bootstrap's theme colors via CSS Variables\n// (Assumes Bootstrap CSS is loaded)\n// const primaryColor = getComputedStyle(document.documentElement)\n//   .getPropertyValue('--bs-primary').trim(); // e.g., '#0d6efd'\n// console.log('Bootstrap Primary Color:', primaryColor);\n\n// document.documentElement.style.setProperty('--bs-primary-rgb', '255, 0, 0'); // Change primary RGB for opacity variants\n// document.documentElement.style.setProperty('--bs-body-font-size', '1.2rem'); // Change body font size\n\n// Conceptual: Programmatic use of a utility-like function if Bootstrap exposed it\n// (Bootstrap primarily exposes component instance methods, not general utility functions for styling)\n// function setElementColor(element, colorName) {\n//   // In reality, you'd apply classes like 'text-primary', 'bg-danger'\n//   // Or if Bootstrap exposed a JS utility (hypothetical):\n//   // BootstrapUtils.setColor(element, 'text', colorName);\n//   // BootstrapUtils.setBackground(element, colorName);\n// }\n\n// Example of using a Bootstrap JS component programmatically\n// const myModalEl = document.getElementById('exampleModal');\n// if (myModalEl) {\n//   const modal = new bootstrap.Modal(myModalEl, { keyboard: false });\n//   // modal.show();\n//   // modal.hide();\n// }"
      },
      {
        "type": "explanation",
        "text": "Bootstrap 5 makes heavy use of CSS Variables (e.g., `--bs-primary`, `--bs-body-font-size`) for theming, which can be manipulated with JavaScript. While a direct 'Utilities API' for applying styles like `text-primary` via JS isn't a main feature, component plugins (like Modal, Popover) have a rich JS API for programmatic control (`new bootstrap.Modal(...)`). The Sass API is more for build-time utility generation."
      }
    ],
    "quiz": {
      "snippet": "// Get the Bootstrap 'danger' color value using JavaScript\n// const dangerColor = getComputedStyle(document.documentElement).getPropertyValue('--bs-danger').trim();",
      "questionText": "How can you programmatically access or modify Bootstrap 5's theme colors (like primary, danger) at runtime in the browser using JavaScript?",
      "options": [
        "By calling `bootstrap.getColor('danger')`",
        "By directly modifying Bootstrap's Sass files via JavaScript",
        "By reading or setting the corresponding CSS Custom Properties (Variables) on the root element (e.g., `--bs-danger`, `--bs-primary-rgb`).",
        "It's not possible; theme colors can only be changed at build time via Sass."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Bootstrap 5 defines its theme colors (and many other properties) as CSS Custom Properties (e.g., `--bs-primary`, `--bs-danger`, `--bs-font-sans-serif`). These can be read using `getComputedStyle(element).getPropertyValue('--bs-property')` and modified at runtime using `element.style.setProperty('--bs-property', 'newValue')`."
    }
  },
  {
    "id": "bootstrap-advanced-custom-form-controls-004",
    "title": "Creating Custom Styled Form Controls with Bootstrap Utilities",
    "difficulty": "advanced",
    "framework": "Bootstrap",
    "frameworkIconText": "BS",
    "tags": [
      "bootstrap",
      "forms",
      "custom forms",
      "utility classes",
      "accessibility"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "While Bootstrap provides default styling for form controls, sometimes you need a completely custom look while still leveraging Bootstrap's layout utilities and ensuring accessibility. This involves using structural HTML, ARIA attributes, and Tailwind-like utility classes from Bootstrap for styling."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<!-- Custom styled checkbox using Bootstrap utilities and structure -->\n<div class=\"form-check custom-checkbox-wrapper my-3\">\n  <input class=\"form-check-input visually-hidden\" type=\"checkbox\" value=\"\" id=\"customCheck1\">\n  <label class=\"form-check-label custom-checkbox-label d-flex align-items-center\" for=\"customCheck1\">\n    <span class=\"custom-checkbox-indicator border border-secondary rounded me-2\"></span>\n    Custom Styled Checkbox\n  </label>\n</div>\n\n<style>\n  /* Minimal custom CSS to style the indicator based on input state */\n  .custom-checkbox-wrapper .form-check-input:checked + .custom-checkbox-label .custom-checkbox-indicator {\n    background-color: var(--bs-primary); /* Use Bootstrap's primary color variable */\n    border-color: var(--bs-primary);\n    /* Add a checkmark icon, e.g., via background-image or pseudo-element */\n  }\n  .custom-checkbox-indicator {\n    display: inline-block;\n    width: 1.25em;\n    height: 1.25em;\n    /* other base styles */\n  }\n</style>\n\n<!-- This example would require more CSS for the checkmark itself -->"
      },
      {
        "type": "explanation",
        "text": "This example hides the default checkbox input (`visually-hidden`) and styles a custom `<span>` (the indicator) and `<label>` using Bootstrap's utility classes (`d-flex`, `align-items-center`, `border`, `rounded`, `me-2`). Custom CSS (or more utilities) would be needed to show the checkmark itself inside the indicator when the input is checked, often using the adjacent sibling selector (`+`) and pseudo-elements."
      }
    ],
    "quiz": {
      "snippet": "<label class=\"btn btn-outline-primary active\">\n  <input type=\"radio\" class=\"visually-hidden\" name=\"options\" id=\"option1\" autocomplete=\"off\" checked>\n  Active Radio\n</label>\n<!-- How can this structure be used for custom radio buttons? -->",
      "questionText": "When creating highly custom-styled form controls (like radio buttons or checkboxes) that integrate with Bootstrap, what is a common approach?",
      "options": [
        "Modifying Bootstrap's core Sass files for each control.",
        "Using only JavaScript to generate and style the controls.",
        "Hiding the default browser input (`.visually-hidden`) and styling a custom element (like a `<label>` or `<span>`) based on the input's state, often using Bootstrap utilities for layout and some base styles.",
        "Using `<iframe>` to embed externally styled controls."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "A common technique for custom form controls is to visually hide the native `<input>` element while keeping it functional for accessibility and state. Then, a sibling element (like a `<label>` or `<span>`) is styled to look like the custom control, and its appearance changes based on the state (e.g., `:checked`) of the hidden native input, often using CSS sibling selectors."
    }
  },
  {
    "id": "bootstrap-advanced-responsive-tables-complex-005",
    "title": "Complex Responsive Tables",
    "difficulty": "advanced",
    "framework": "Bootstrap",
    "frameworkIconText": "BS",
    "tags": [
      "bootstrap",
      "tables",
      "responsive tables",
      "data attributes",
      "css pseudo-elements"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "For very wide tables, Bootstrap's basic responsive table (`.table-responsive`) adds a horizontal scrollbar. For more complex responsive behavior where table cells stack or reformat on small screens, you might need custom CSS leveraging data attributes and pseudo-elements, while still using Bootstrap's base table styling."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<table class=\"table table-bordered custom-responsive-table\">\n  <thead>\n    <tr>\n      <th>ID</th><th>Name</th><th>Email</th><th>Role</th><th>Status</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td data-label=\"ID\">1</td>\n      <td data-label=\"Name\">Alice Johnson</td>\n      <td data-label=\"Email\">alice@example.com</td>\n      <td data-label=\"Role\">Admin</td>\n      <td data-label=\"Status\"><span class=\"badge bg-success\">Active</span></td>\n    </tr>\n    <tr>\n      <td data-label=\"ID\">2</td>\n      <td data-label=\"Name\">Bob Smith</td>\n      <td data-label=\"Email\">bob@example.com</td>\n      <td data-label=\"Role\">Editor</td>\n      <td data-label=\"Status\"><span class=\"badge bg-warning text-dark\">Pending</span></td>\n    </tr>\n  </tbody>\n</table>\n\n<style>\n/* Custom CSS for stacking table cells on small screens */\n@media (max-width: 767.98px) { /* Below Bootstrap's 'md' breakpoint */\n  .custom-responsive-table thead {\n    display: none; /* Hide table headers */\n  }\n  .custom-responsive-table tbody, .custom-responsive-table tr, .custom-responsive-table td {\n    display: block;\n    width: 100%;\n  }\n  .custom-responsive-table tr {\n    margin-bottom: 1rem;\n    border-bottom: 2px solid #dee2e6;\n  }\n  .custom-responsive-table td {\n    text-align: right;\n    padding-left: 50%; /* Make space for the label */\n    position: relative;\n    border-bottom: 1px solid #eee;\n  }\n  .custom-responsive-table td::before {\n    content: attr(data-label); /* Use data-label for the heading */\n    position: absolute;\n    left: 0.5rem;\n    width: calc(50% - 1rem);\n    padding-right: 0.5rem;\n    font-weight: bold;\n    text-align: left;\n    white-space: nowrap;\n  }\n  .custom-responsive-table td:last-child {\n    border-bottom: 0;\n  }\n}\n</style>"
      },
      {
        "type": "explanation",
        "text": "This approach uses custom CSS for screens smaller than `md`. Table headers are hidden, and each `<td>` is styled to display as a block. A `::before` pseudo-element on each `<td>` uses the content of its `data-label` attribute to display what would have been the column header, creating a stacked, card-like appearance for each row on mobile."
      }
    ],
    "quiz": {
      "snippet": "<!-- <td data-label=\"User Role\">Administrator</td> -->\n<!-- CSS: td::before { content: attr(data-label); font-weight: bold; } -->",
      "questionText": "In a custom responsive table solution like the example, what is the purpose of using `data-label` attributes on `<td>` elements and `attr(data-label)` in CSS pseudo-elements?",
      "options": [
        "To add extra padding to table cells.",
        "To provide data for JavaScript to manipulate table sorting.",
        "To store the original column header text, which can then be displayed (e.g., by a `::before` pseudo-element) when the table layout changes to a stacked format on small screens.",
        "To define a unique ID for each table cell."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "When reformatting a table for small screens (e.g., stacking cells), the original table headers (`<thead>`) are often hidden. `data-label` attributes on `<td>` elements store the corresponding header text. CSS `::before` pseudo-elements can then use `content: attr(data-label);` to display these labels next to or above the cell's content in the stacked layout."
    }
  },
  {
    "id": "bulma-advanced-custom-hero-video-001",
    "title": "Hero Section with Video Background & Overlay",
    "difficulty": "advanced",
    "framework": "Bulma",
    "frameworkIconText": "Bulma",
    "tags": [
      "bulma",
      "hero",
      "video background",
      "overlay",
      "layout",
      "custom css"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Creating a hero section with a video background and a semi-transparent overlay for text readability requires careful layering and positioning. Bulma's `hero` component provides a base, but custom CSS is often needed for the video and overlay."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<section class=\"hero is-fullheight has-video-background\">\n  <div class=\"hero-video-wrapper\">\n    <video playsinline autoplay muted loop poster=\"placeholder.jpg\" id=\"bgvideo\">\n      <source src=\"path/to/your/video.mp4\" type=\"video/mp4\">\n    </video>\n  </div>\n  <div class=\"hero-body\">\n    <div class=\"container has-text-centered\">\n      <p class=\"title is-1 has-text-white has-text-shadow\">\n        Impactful Headline\n      </p>\n      <p class=\"subtitle is-3 has-text-light has-text-shadow\">\n        Engaging subheadline here.\n      </p>\n      <a class=\"button is-primary is-large\">Call to Action</a>\n    </div>\n  </div>\n</section>\n\n<style>\n/* This CSS would typically be in your own stylesheet */\n.has-video-background {\n  position: relative; /* For absolute positioning of video and overlay */\n  overflow: hidden; /* To contain the video */\n}\n.hero-video-wrapper {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: -2; /* Behind hero-body and any overlay */\n  overflow: hidden;\n}\n.hero-video-wrapper video {\n  min-width: 100%;\n  min-height: 100%;\n  width: auto;\n  height: auto;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%); /* Center the video */\n  object-fit: cover; /* Cover the area, might crop */\n}\n/* Optional: Add a semi-transparent overlay for text readability */\n.hero.has-video-background::before {\n  content: '';\n  position: absolute;\n  top: 0; left: 0; right: 0; bottom: 0;\n  background-color: rgba(0, 0, 0, 0.4); /* Dark overlay */\n  z-index: -1; /* Between video and content */\n}\n.has-text-shadow {\n  text-shadow: 1px 1px 3px rgba(0,0,0,0.7);\n}\n</style>"
      },
      {
        "type": "explanation",
        "text": "The `.hero` section is made `position: relative`. The video is wrapped and absolutely positioned to cover the hero area, with a lower `z-index`. An optional `::before` pseudo-element on the hero creates a semi-transparent overlay between the video and the `hero-body` content. Custom CSS is essential here as Bulma doesn't provide video background utilities out-of-the-box."
      }
    ],
    "quiz": {
      "snippet": "<section class=\"hero is-primary\">\n  <div class=\"hero-body\">\n    <!-- How to make text more readable over a busy background image/video? -->\n  </div>\n</section>",
      "questionText": "When placing text over a complex background (like a video or busy image) in a Bulma hero section, what is a common technique to improve text readability?",
      "options": [
        "Making the text transparent.",
        "Adding a semi-transparent overlay (e.g., a dark `rgba` background) between the background and the text, or adding text shadow.",
        "Significantly increasing the font size only.",
        "Using only `is-light` color modifiers for the text."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "To improve text readability over complex backgrounds, a common technique is to add a semi-transparent overlay (e.g., `background-color: rgba(0,0,0,0.5);`) or apply a text shadow (`text-shadow`) to the text itself. This creates better contrast."
    }
  },
  {
    "id": "bulma-advanced-megamenu-dropdown-002",
    "title": "Creating a Mega Menu / Complex Dropdown with Columns",
    "difficulty": "advanced",
    "framework": "Bulma",
    "frameworkIconText": "Bulma",
    "tags": [
      "bulma",
      "navbar",
      "dropdown",
      "mega menu",
      "columns",
      "custom css",
      "javascript needed"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Bulma's standard dropdown is simple. A 'mega menu' often involves a wider dropdown panel containing multiple columns of links or content. This usually requires custom HTML structure within a `navbar-item has-dropdown` and custom CSS for styling, plus JavaScript to control visibility."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<nav class=\"navbar\" role=\"navigation\" aria-label=\"main navigation\">\n  <div class=\"navbar-brand\"><a class=\"navbar-item\">Brand</a></div>\n  <div class=\"navbar-menu\">\n    <div class=\"navbar-start\">\n      <div class=\"navbar-item has-dropdown is-hoverable\"> <!-- or is-active for JS control -->\n        <a class=\"navbar-link\">Mega Menu</a>\n        <div class=\"navbar-dropdown is-boxed\" style=\"width: 400px; /* Custom width */\">\n          <div class=\"container p-2\">\n            <div class=\"columns\">\n              <div class=\"column\">\n                <p class=\"has-text-weight-bold\">Category 1</p>\n                <a class=\"navbar-item\">Link 1.1</a>\n                <a class=\"navbar-item\">Link 1.2</a>\n              </div>\n              <div class=\"column\">\n                <p class=\"has-text-weight-bold\">Category 2</p>\n                <a class=\"navbar-item\">Link 2.1</a>\n                <a class=\"navbar-item\">Link 2.2</a>\n              </div>\n            </div>\n          </div>\n          <hr class=\"navbar-divider\">\n          <a class=\"navbar-item\">Featured Item</a>\n        </div>\n      </div>\n      <a class=\"navbar-item\">Other Link</a>\n    </div>\n  </div>\n</nav>\n\n<!-- JavaScript would be needed to toggle 'is-active' on '.has-dropdown' for click-triggered mega menus -->"
      },
      {
        "type": "explanation",
        "text": "The `.navbar-dropdown` is given a custom width. Inside it, Bulma's `columns` and `column` classes are used to structure the content. `is-hoverable` makes it appear on hover. For click-triggered mega menus, JavaScript would toggle an `is-active` class on the `.has-dropdown` element."
      }
    ],
    "quiz": {
      "snippet": "<div class=\"navbar-item has-dropdown\">\n  <a class=\"navbar-link\">Products</a>\n  <div class=\"navbar-dropdown\" style=\"width: 500px;\">\n    <!-- Columns and content here -->\n  </div>\n</div>",
      "questionText": "To create a wide, multi-column 'mega menu' dropdown in a Bulma navbar, what combination of techniques is typically used?",
      "options": [
        "Only built-in Bulma JavaScript functions.",
        "Using the `is-megamenu` Bulma class.",
        "Custom HTML structure (often with Bulma `columns`) inside `.navbar-dropdown`, custom CSS for sizing/styling, and potentially JavaScript for click-toggle behavior.",
        "Exclusively using `<table>` elements within the dropdown."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Bulma doesn't have a dedicated 'mega menu' component. You create one by customizing the `.navbar-dropdown`, often giving it a fixed width, and then using Bulma's `columns` or other layout utilities inside it. JavaScript is usually needed if you want it to be click-triggered instead of hover-triggered (`is-hoverable`)."
    }
  },
  {
    "id": "bulma-advanced-custom-stepper-003",
    "title": "Building a Step/Progress Indicator",
    "difficulty": "advanced",
    "framework": "Bulma",
    "frameworkIconText": "Bulma",
    "tags": [
      "bulma",
      "steps",
      "progress indicator",
      "custom component",
      "flexbox",
      "css"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Creating a multi-step progress indicator (stepper) often involves combining Bulma's layout utilities (like flexbox) with custom CSS for the step connections and active states. JavaScript would be needed to control which step is currently active."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<nav class=\"steps is-small is-centered has-content-centered\">\n  <div class=\"step-item is-active is-completed\">\n    <div class=\"step-marker\">1</div>\n    <div class=\"step-details\">\n      <p class=\"step-title\">Account</p>\n    </div>\n  </div>\n  <div class=\"step-item is-active\">\n    <div class=\"step-marker\">2</div>\n    <div class=\"step-details\">\n      <p class=\"step-title\">Profile</p>\n    </div>\n  </div>\n  <div class=\"step-item\">\n    <div class=\"step-marker\">3</div>\n    <div class=\"step-details\">\n      <p class=\"step-title\">Finish</p>\n    </div>\n  </div>\n</nav>\n\n<!-- Partial Custom SCSS for Bulma 'steps' component (often found in Bulma extensions or custom code) -->\n<!-- \n.steps {\n  display: flex; \n  .step-item {\n    display: flex; align-items: center; flex-grow: 1; position: relative;\n    &:not(:last-child)::after { /* Connector line */\n      content: ''; height: 2px; background-color: #dbdbdb; flex-grow: 1; margin: 0 1em;\n    }\n    &.is-active .step-marker { background-color: var(--bulma-primary, #00d1b2); color: white; }\n    &.is-completed .step-marker { background-color: var(--bulma-success, #48c774); color: white; }\n    &.is-completed:not(:last-child)::after { background-color: var(--bulma-success, #48c774); }\n  }\n  .step-marker { /* ... styles for circle ... */ }\n  .step-details { /* ... styles for text ... */ }\n}\n-->"
      },
      {
        "type": "explanation",
        "text": "This example shows the HTML structure for a common 'steps' component pattern. The actual styling for the lines connecting steps, active states, and completed states usually comes from a Bulma extension (like `bulma-steps`) or custom CSS. JavaScript would toggle the `is-active` and `is-completed` classes."
      }
    ],
    "quiz": {
      "snippet": "<div class=\"step-item is-completed\">\n  <div class=\"step-marker\">✓</div> <!-- Checkmark -->\n  <div class=\"step-details\">Step Name</div>\n</div>",
      "questionText": "When building a custom step/progress indicator with Bulma, how are the connecting lines between steps typically created if not provided by a specific Bulma extension?",
      "options": [
        "Using `<hr>` elements automatically styled by Bulma.",
        "Using JavaScript to draw lines on an HTML5 canvas.",
        "Using CSS pseudo-elements (like `::before` or `::after`) on the `step-item` elements, styled to look like lines.",
        "Bulma automatically adds lines if `step-item` elements are siblings."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "For custom step indicators, connecting lines are often created using CSS pseudo-elements (`::after` or `::before`) on the list items or step items. These pseudo-elements are then styled (e.g., with a height, background color, and appropriate positioning) to form the visual connection."
    }
  },
  {
    "id": "bulma-advanced-responsive-helpers-visibility-004",
    "title": "Advanced Responsive Helpers & Visibility",
    "difficulty": "advanced",
    "framework": "Bulma",
    "frameworkIconText": "Bulma",
    "tags": [
      "bulma",
      "responsive helpers",
      "visibility",
      "is-hidden-touch",
      "is-flex-desktop-only"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Bulma provides a rich set of responsive helper classes to show or hide content, or change display properties (like `flex`, `block`) at specific breakpoints. These are crucial for crafting adaptive user interfaces."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<div class=\"box\">\n  <p class=\"is-hidden-mobile is-block-tablet\">Visible on tablet and wider, hidden on mobile.</p>\n  <p class=\"is-hidden-tablet-only\">Visible on mobile and desktop/widescreen, hidden ONLY on tablet.</p>\n  <p class=\"is-flex-touch is-block-desktop\">Displays as flex on touch devices (mobile & tablet), block on desktop.</p>\n  <p class=\"is-hidden-desktop-only\">Hidden only on desktop, visible on mobile, tablet, widescreen.</p>\n</div>\n\n<div class=\"tabs is-centered\">\n  <ul>\n    <li class=\"is-active\"><a>Pictures</a></li>\n    <li><a>Music</a></li>\n    <li class=\"is-hidden-touch\"><a>Videos (Desktop only tab)</a></li>\n    <li><a>Documents</a></li>\n  </ul>\n</div>"
      },
      {
        "type": "explanation",
        "text": "`is-hidden-mobile` hides content on mobile. `is-block-tablet` displays content as block from tablet upwards. `is-hidden-tablet-only` specifically hides on tablet. `is-flex-touch` applies `display: flex` on touch devices (mobile and tablet). These can be combined to create complex responsive visibility rules."
      }
    ],
    "quiz": {
      "snippet": "<div class=\"is-flex is-hidden-widescreen is-flex-tablet-only is-block-mobile\">\n  Content\n</div>",
      "questionText": "Which display property will the div have on a 'desktop' screen size (assuming default Bulma breakpoints: mobile < 769px, tablet 769px-1023px, desktop 1024px-1215px, widescreen 1216px+)?",
      "options": [
        "`display: flex;`",
        "`display: block;`",
        "`display: none;` (hidden)",
        "Default browser display (likely `block` for a div)"
      ],
      "correctOptionIndex": 0,
      "explanationAfterAnswer": "Let's break it down: `is-flex` (default display flex). `is-hidden-widescreen` (hides on widescreen). `is-flex-tablet-only` (applies flex only on tablet). `is-block-mobile` (applies block on mobile). For desktop (between tablet and widescreen), the most general `is-flex` would apply as it's not overridden by a more specific desktop visibility/display class in this set."
    }
  },
  {
    "id": "bulma-advanced-elements-vs-components-005",
    "title": "Understanding Elements vs. Components & Modifiers",
    "difficulty": "advanced",
    "framework": "Bulma",
    "frameworkIconText": "Bulma",
    "tags": [
      "bulma",
      "elements",
      "components",
      "modifiers",
      "syntax",
      "css architecture"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Bulma's class naming convention distinguishes between 'Elements' (basic building blocks like `button`, `tag`, `title`), 'Components' (more complex UI structures like `card`, `navbar`, `modal`), and 'Modifiers' (classes starting with `is-` or `has-` that alter the style or behavior of elements/components). Understanding this distinction helps in using Bulma effectively."
      },
      {
        "type": "code",
        "language": "html",
        "code": "<!-- Element: button -->\n<button class=\"button is-primary is-large is-loading\">\n  Processing...\n</button>\n<!-- \n  'button' is the element class.\n  'is-primary', 'is-large', 'is-loading' are modifier classes.\n-->\n\n<!-- Component: message -->\n<article class=\"message is-info\">\n  <div class=\"message-header\">\n    <p>Information</p>\n    <button class=\"delete\" aria-label=\"delete\"></button>\n  </div>\n  <div class=\"message-body\">\n    This is an informational message component.\n  </div>\n</article>\n<!-- \n  'message' is the component class.\n  'is-info' is a color modifier.\n  'message-header', 'message-body', 'delete' are sub-elements of the component.\n-->\n\n<div class=\"field has-addons\">\n  <p class=\"control\">\n    <input class=\"input\" type=\"text\" placeholder=\"Find a repository\">\n  </p>\n  <p class=\"control\">\n    <a class=\"button is-info\">\n      Search\n    </a>\n  </p>\n</div>\n<!-- \n  'field' and 'control' are layout helper elements.\n  'has-addons' is a modifier on 'field' to join controls together.\n-->"
      },
      {
        "type": "explanation",
        "text": "Elements are single classes (e.g., `.title`, `.input`). Components have a main class (e.g., `.card`, `.navbar`) and often several sub-element classes (e.g., `.card-header`, `.navbar-item`). Modifiers (e.g., `.is-active`, `.is-centered`, `.has-text-danger`) change the appearance or state of these elements or components."
      }
    ],
    "quiz": {
      "snippet": "<span class=\"tag is-link is-light is-rounded\">Tech</span>",
      "questionText": "In the Bulma snippet `<span class=\"tag is-link is-light is-rounded\">Tech</span>`, which class identifies the base Bulma 'Element' being used?",
      "options": ["is-link", "is-light", "is-rounded", "tag"],
      "correctOptionIndex": 3,
      "explanationAfterAnswer": "`tag` is the base Bulma element class. `is-link`, `is-light`, and `is-rounded` are modifier classes that alter the appearance (color, style, shape) of the base `tag` element."
    }
  },
  {
    "id": "threejs-advanced-custom-shaders-glsl-001",
    "title": "Custom Shaders with GLSL (ShaderMaterial)",
    "difficulty": "advanced",
    "framework": "Three.js",
    "frameworkIconText": "3D GLSL",
    "tags": [
      "threejs",
      "shaders",
      "glsl",
      "ShaderMaterial",
      "vertex shader",
      "fragment shader",
      "gpu"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "For ultimate control over how objects are rendered, you can write custom shaders using GLSL (OpenGL Shading Language). Three.js provides `ShaderMaterial` (or `RawShaderMaterial`) to use your custom vertex and fragment shaders, allowing for unique visual effects processed directly on the GPU."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Assume scene, camera, renderer are set up\n\nconst vertexShader = `\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n`;\n\nconst fragmentShader = `\n  uniform float uTime;\n  uniform vec3 uColor1;\n  uniform vec3 uColor2;\n  varying vec2 vUv;\n\n  void main() {\n    float mixValue = abs(sin(vUv.x * 10.0 + uTime * 2.0));\n    vec3 color = mix(uColor1, uColor2, mixValue);\n    gl_FragColor = vec4(color, 1.0);\n  }\n`;\n\nconst shaderMaterial = new THREE.ShaderMaterial({\n  uniforms: {\n    uTime: { value: 0.0 },\n    uColor1: { value: new THREE.Color(0xff0000) }, // Red\n    uColor2: { value: new THREE.Color(0x0000ff) }  // Blue\n  },\n  vertexShader: vertexShader,\n  fragmentShader: fragmentShader\n});\n\nconst planeGeometry = new THREE.PlaneGeometry(4, 4);\nconst shaderPlane = new THREE.Mesh(planeGeometry, shaderMaterial);\nscene.add(shaderPlane);\ncamera.position.z = 3;\n\nlet clock = new THREE.Clock();\nfunction animate() {\n  requestAnimationFrame(animate);\n  shaderMaterial.uniforms.uTime.value = clock.getElapsedTime();\n  renderer.render(scene, camera);\n}\nif (typeof renderer !== 'undefined') animate();"
      },
      {
        "type": "explanation",
        "text": "The vertex shader positions vertices. The fragment shader determines the color of each pixel. `uniforms` are variables passed from JavaScript to the shaders (e.g., `uTime` for animation). `varying vec2 vUv` passes UV coordinates from vertex to fragment shader. This example creates a plane with colors that shift based on time and UV coordinates."
      }
    ],
    "quiz": {
      "snippet": "// Vertex Shader: calculates gl_Position\n// Fragment Shader: calculates gl_FragColor\n// Uniforms: variables passed from JS to shaders\n// Varyings: variables passed from vertex to fragment shader",
      "questionText": "In GLSL shaders used with Three.js `ShaderMaterial`, what is the primary role of a 'uniform' variable?",
      "options": [
        "To store per-vertex attributes like position or UV coordinates.",
        "To pass data from the vertex shader to the fragment shader for each pixel.",
        "To provide global variables that are constant for all vertices/fragments in a draw call, passed from JavaScript to the shaders.",
        "To define the final color of a pixel."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Uniforms are variables whose values are constant for all vertices and fragments processed in a single draw call. They are set in JavaScript (via `material.uniforms.myUniform.value = ...`) and passed to both vertex and fragment shaders, allowing for dynamic control over shader behavior from the CPU."
    }
  },
  {
    "id": "threejs-advanced-postprocessing-002",
    "title": "Post-Processing Effects (EffectComposer)",
    "difficulty": "advanced",
    "framework": "Three.js",
    "frameworkIconText": "3D FX",
    "tags": [
      "threejs",
      "post-processing",
      "EffectComposer",
      "RenderPass",
      "ShaderPass",
      "effects"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Post-processing allows you to apply full-screen effects to your rendered scene, like bloom, depth of field, film grain, or custom shader effects. Three.js uses an `EffectComposer` to chain together multiple render passes."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Assume scene, camera, renderer are set up\n// Import necessary passes, e.g.:\n// import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\n// import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\n// import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';\n// import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';\n\n// 1. Create EffectComposer\nconst composer = new THREE.EffectComposer(renderer);\n\n// 2. Add RenderPass (renders the main scene)\nconst renderPass = new THREE.RenderPass(scene, camera);\ncomposer.addPass(renderPass);\n\n// 3. Add BloomPass (example effect)\nconst bloomPass = new THREE.UnrealBloomPass(\n  new THREE.Vector2(window.innerWidth, window.innerHeight),\n  1.5, // strength\n  0.4, // radius\n  0.85 // threshold\n);\ncomposer.addPass(bloomPass);\n\n// 4. Add OutputPass (renders to screen, handles color encoding)\nconst outputPass = new THREE.OutputPass();\ncomposer.addPass(outputPass);\n\n// In your animation loop, render using the composer instead of the renderer directly:\nfunction animate() {\n  requestAnimationFrame(animate);\n  // ... update scene objects ...\n  // renderer.render(scene, camera); // Old way\n  composer.render(); // New way\n}\n// Remember to update composer size on window resize: composer.setSize(...)"
      },
      {
        "type": "explanation",
        "text": "An `EffectComposer` takes the renderer as an argument. A `RenderPass` is usually the first pass, rendering your scene to a texture. Subsequent passes (like `UnrealBloomPass` or custom `ShaderPass` instances) take the output of the previous pass as input and apply effects. The final pass (often `OutputPass`) renders the result to the screen."
      }
    ],
    "quiz": {
      "snippet": "const composer = new EffectComposer(renderer);\ncomposer.addPass(new RenderPass(scene, camera));\nconst glitchPass = new GlitchPass();\ncomposer.addPass(glitchPass);\n// In render loop: composer.render();",
      "questionText": "What is the role of the `EffectComposer` in Three.js post-processing?",
      "options": [
        "It's a special type of camera for rendering effects.",
        "It's a material that applies visual effects directly to meshes.",
        "It manages a chain of render passes, where each pass can apply a visual effect to the output of the previous pass, before rendering the final result.",
        "It's a loader for importing pre-made visual effect files."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "The `EffectComposer` is a manager for a pipeline of post-processing passes. It takes the initial rendered scene (usually from a `RenderPass`) and feeds its output through a sequence of other effect passes (e.g., bloom, blur, custom shaders via `ShaderPass`) before displaying the final image."
    }
  },
  {
    "id": "threejs-advanced-physics-integration-003",
    "title": "Physics Engine Integration (Conceptual with Cannon.js/Rapier)",
    "difficulty": "advanced",
    "framework": "Three.js",
    "frameworkIconText": "3D Phys",
    "tags": [
      "threejs",
      "physics",
      "cannon.js",
      "rapier",
      "collision detection",
      "rigid bodies"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "For realistic physical interactions (gravity, collisions, forces), you need to integrate a physics engine with Three.js. Popular choices include Cannon.js (older, simpler) or Rapier (Rust-based, compiled to Wasm, more performant). The physics engine runs its own simulation, and you synchronize the positions/rotations of Three.js meshes with their corresponding physics bodies."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Conceptual example using a generic physics world idea\n// (Actual implementation depends heavily on the chosen physics library)\n\n// --- Initialization ---\n// const world = new PHYSICS_LIB.World();\n// world.gravity.set(0, -9.82, 0);\n\n// const threeMesh = new THREE.Mesh(geometry, material);\n// scene.add(threeMesh);\n\n// const physicsBody = new PHYSICS_LIB.Body({ mass: 1, shape: new PHYSICS_LIB.Box(new Vec3(0.5,0.5,0.5)) });\n// physicsBody.position.set(threeMesh.position.x, threeMesh.position.y, threeMesh.position.z);\n// world.addBody(physicsBody);\n\n// Store pairs: [{ mesh: threeMesh, body: physicsBody }, ...]\n// const objectsToUpdate = [];\n// objectsToUpdate.push({ mesh: threeMesh, body: physicsBody });\n\n// --- Animation Loop ---\n// let lastTime = 0;\n// function animate(time) {\n//   requestAnimationFrame(animate);\n//   const deltaTime = (time - lastTime) / 1000 || 0.016;\n//   lastTime = time;\n\n//   world.step(1/60, deltaTime, 3); // Step the physics world\n\n//   for (const obj of objectsToUpdate) {\n//     obj.mesh.position.copy(obj.body.position);\n//     obj.mesh.quaternion.copy(obj.body.quaternion);\n//   }\n//   renderer.render(scene, camera);\n// }"
      },
      {
        "type": "explanation",
        "text": "The core idea is: 1. Create Three.js meshes for visuals. 2. Create corresponding rigid bodies with shapes and mass in the physics world. 3. In each animation frame, step the physics simulation forward. 4. Update the position and rotation of each Three.js mesh to match its corresponding physics body. Collision detection and responses are handled by the physics engine."
      }
    ],
    "quiz": {
      "snippet": "// In the animation loop:\n// physicsWorld.step(deltaTime);\n// myThreeMesh.position.copy(myPhysicsBody.position);\n// myThreeMesh.quaternion.copy(myPhysicsBody.quaternion);",
      "questionText": "When integrating a physics engine with Three.js, what is the typical flow of information in the animation loop?",
      "options": [
        "Three.js updates mesh positions, then the physics engine calculates forces.",
        "The physics engine simulates physics and updates body positions/rotations, then Three.js meshes are updated to match these physics bodies.",
        "Both Three.js and the physics engine update positions independently, then synchronize.",
        "User input directly controls physics body positions, which then update Three.js meshes."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "Typically, the physics engine runs its simulation to calculate new positions and orientations for rigid bodies based on forces, collisions, etc. Then, in each frame of the animation loop, the visual Three.js meshes have their `position` and `quaternion` (for rotation) updated to match the corresponding state of their physics body counterparts."
    }
  },
  {
    "id": "threejs-advanced-raycasting-interaction-004",
    "title": "Advanced Object Interaction with Raycasting",
    "difficulty": "advanced",
    "framework": "Three.js",
    "frameworkIconText": "3D Interact",
    "tags": [
      "threejs",
      "raycasting",
      "interaction",
      "mouse picking",
      "occlusion"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Raycasting is a technique used to determine which objects in a 3D scene intersect with a ray (a line extending infinitely from an origin in a certain direction). It's fundamental for mouse picking (clicking on objects), collision detection (though physics engines are better for complex physics), and other forms of interaction."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Assume scene, camera, renderer, and an array 'interactiveObjects' are set up\n\n// const raycaster = new THREE.Raycaster();\n// const mouse = new THREE.Vector2(); // Normalized device coordinates (-1 to +1)\n\n// function onMouseMove(event) {\n//   // Calculate mouse position in normalized device coordinates\n//   mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n//   mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n// }\n\n// function onClick(event) {\n//   // Update the picking ray with the camera and mouse position\n//   raycaster.setFromCamera(mouse, camera);\n\n//   // Calculate objects intersecting the picking ray\n//   const intersects = raycaster.intersectObjects(scene.children, true); // Check all descendants\n//   // Or: const intersects = raycaster.intersectObjects(interactiveObjects);\n\n//   if (intersects.length > 0) {\n//     // intersects[0] is the closest object\n//     const firstIntersectedObject = intersects[0].object;\n//     console.log('Clicked on:', firstIntersectedObject.name || firstIntersectedObject.uuid);\n//     // Example: Change its color\n//     // if (firstIntersectedObject.material) {\n//     //   firstIntersectedObject.material.color.set(Math.random() * 0xffffff);\n//     // }\n//   }\n// }\n\n// window.addEventListener('mousemove', onMouseMove, false);\n// window.addEventListener('click', onClick, false);\n\n// // Render loop\n// function animate() { /* ... */ }"
      },
      {
        "type": "explanation",
        "text": "A `Raycaster` is created. On mouse events, the mouse coordinates are converted to normalized device coordinates. `raycaster.setFromCamera(mouse, camera)` updates the ray. `raycaster.intersectObjects(objects)` returns an array of intersected objects, sorted by distance. This allows for precise selection of 3D objects."
      }
    ],
    "quiz": {
      "snippet": "raycaster.setFromCamera(mouseCoords, camera);\nconst intersects = raycaster.intersectObjects(selectableMeshes);",
      "questionText": "What does the `raycaster.intersectObjects(objects)` method in Three.js primarily return?",
      "options": [
        "A boolean indicating if any object was intersected.",
        "The single closest intersected object.",
        "An array of all objects in the scene that intersect with the ray, sorted by distance from the ray's origin.",
        "The 3D coordinates of the intersection point on the first object hit."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "`raycaster.intersectObjects()` returns an array containing all objects from the provided list that intersect with the ray. The array is sorted by distance, with the closest intersection being the first element. Each element in the array provides details about the intersection (distance, point, face, object)."
    }
  },
  {
    "id": "threejs-advanced-optimization-instancing-005",
    "title": "Performance Optimization: Instanced Rendering",
    "difficulty": "advanced",
    "framework": "Three.js",
    "frameworkIconText": "3D Perf",
    "tags": [
      "threejs",
      "performance",
      "instanced rendering",
      "InstancedMesh",
      "draw calls",
      "optimization"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "When rendering a large number of identical (or very similar) objects, creating a separate `THREE.Mesh` for each can lead to many draw calls and performance bottlenecks. Instanced rendering (`THREE.InstancedMesh`) allows you to draw multiple instances of the same geometry and material in a single draw call, significantly improving performance."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Assume scene, camera, renderer are set up\n\nconst count = 10000; // Number of instances\nconst geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);\nconst material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });\n\n// Create an InstancedMesh\n// Args: geometry, material, count\nconst instancedMesh = new THREE.InstancedMesh(geometry, material, count);\n\n// Set up transformations for each instance\nconst dummy = new THREE.Object3D(); // Helper object to set matrix\nfor (let i = 0; i < count; i++) {\n  dummy.position.set(\n    (Math.random() - 0.5) * 10,\n    (Math.random() - 0.5) * 10,\n    (Math.random() - 0.5) * 10\n  );\n  dummy.rotation.set(\n    Math.random() * Math.PI,\n    Math.random() * Math.PI,\n    Math.random() * Math.PI\n  );\n  dummy.updateMatrix(); // Important: update matrix after changing position/rotation/scale\n  instancedMesh.setMatrixAt(i, dummy.matrix); // Set the transformation matrix for instance i\n}\ninstancedMesh.instanceMatrix.needsUpdate = true; // Tell Three.js to update the instance matrix buffer\n\n// Optional: Per-instance color (requires modifying material's vertexColors and geometry attributes)\n// const colors = [];\n// for (let i = 0; i < count; i++) { colors.push(Math.random(), Math.random(), Math.random()); }\n// geometry.setAttribute('color', new THREE.InstancedBufferAttribute(new Float32Array(colors), 3));\n// material.vertexColors = true;\n\nscene.add(instancedMesh);\n// Add lights for MeshStandardMaterial\n// ... (camera, animation loop) ..."
      },
      {
        "type": "explanation",
        "text": "`InstancedMesh` takes a geometry, material, and the number of instances. You then set the transformation matrix (position, rotation, scale) for each instance using `setMatrixAt(index, matrix)`. This allows rendering thousands or even millions of similar objects with good performance by dramatically reducing draw calls."
      }
    ],
    "quiz": {
      "snippet": "// Rendering 10,000 identical trees in a forest scene.\n// Each tree has the same geometry and material, but different positions and rotations.",
      "questionText": "What is the primary performance benefit of using `THREE.InstancedMesh` to render many identical objects?",
      "options": [
        "It automatically uses lower-polygon versions of the geometry for distant objects.",
        "It reduces the amount of JavaScript code needed to define the objects.",
        "It significantly reduces the number of draw calls to the GPU by drawing many instances of the same geometry/material in a single operation.",
        "It enables per-instance physics simulations."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "The main advantage of `InstancedMesh` is performance through draw call reduction. Instead of telling the GPU to draw each object individually (one draw call per object), instancing allows the GPU to draw many copies of the same object with different transformations (position, rotation, scale) in a single, more efficient draw call."
    }
  },
  {
    "id": "pixijs-advanced-custom-filter-shader-001",
    "title": "Custom Filters with GLSL Shaders",
    "difficulty": "advanced",
    "framework": "PixiJS",
    "frameworkIconText": "PixiGLSL",
    "tags": [
      "pixijs",
      "custom filter",
      "glsl",
      "shaders",
      "fragment shader",
      "uniforms"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "For unique visual effects beyond built-in filters, you can create custom filters using GLSL (OpenGL Shading Language). A custom filter typically involves writing a fragment shader that manipulates pixel colors based on uniforms and texture coordinates."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Assume 'app' is created and a 'sprite' is on stage\n// const sprite = PIXI.Sprite.from('assets/myImage.png'); app.stage.addChild(sprite);\n\nconst vertexSrc = `\n  attribute vec2 aVertexPosition;\n  attribute vec2 aTextureCoord;\n  uniform mat3 projectionMatrix;\n  varying vec2 vTextureCoord;\n  void main(void) {\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n  }\n`;\n\nconst fragmentSrc = `\n  varying vec2 vTextureCoord;\n  uniform sampler2D uSampler; // Original texture\n  uniform float uTime; // Time uniform for animation\n\n  void main(void) {\n    vec4 originalColor = texture2D(uSampler, vTextureCoord);\n    // Example: Distort texture coordinates over time\n    float distortion = sin(vTextureCoord.y * 10.0 + uTime) * 0.05;\n    vec2 distortedCoords = vec2(vTextureCoord.x + distortion, vTextureCoord.y);\n    gl_FragColor = texture2D(uSampler, distortedCoords) * originalColor.a;\n    // gl_FragColor = vec4(originalColor.r * sin(uTime), originalColor.g, originalColor.b, originalColor.a);\n  }\n`;\n\nconst myUniforms = {\n  uTime: 0.0,\n};\n\nconst customFilter = new PIXI.Filter(vertexSrc, fragmentSrc, myUniforms);\n// sprite.filters = [customFilter];\n\n// In the ticker to animate the uniform:\n// app.ticker.add((delta) => {\n//   customFilter.uniforms.uTime += 0.01 * delta;\n// });"
      },
      {
        "type": "explanation",
        "text": "A `PIXI.Filter` is created with a vertex shader (usually standard for filters) and a custom fragment shader. The fragment shader receives the original texture (`uSampler`), texture coordinates (`vTextureCoord`), and any custom `uniforms` (like `uTime`). It then calculates the final pixel color (`gl_FragColor`)."
      }
    ],
    "quiz": {
      "snippet": "// Fragment Shader for a custom PixiJS filter\n// varying vec2 vTextureCoord;\n// uniform sampler2D uSampler;\n// uniform float uIntensity;\n// void main() {\n//   vec4 color = texture2D(uSampler, vTextureCoord);\n//   gl_FragColor = vec4(color.rgb * uIntensity, color.a);\n// }",
      "questionText": "In a custom PixiJS filter's fragment shader, what does `uSampler` (a `uniform sampler2D`) typically represent?",
      "options": [
        "A 2D vector for screen position.",
        "The input texture (the rendered content of the display object the filter is applied to).",
        "A lookup table for color correction.",
        "A timer uniform for animations."
      ],
      "correctOptionIndex": 1,
      "explanationAfterAnswer": "`uSampler` (or a similar name by convention) is a uniform of type `sampler2D` that provides access to the texture of the display object (or the result of the previous filter pass) that the current filter is being applied to. `texture2D(uSampler, vTextureCoord)` samples a color from this texture."
    }
  },
  {
    "id": "pixijs-advanced-optim-object-pooling-002",
    "title": "Performance: Object Pooling",
    "difficulty": "advanced",
    "framework": "PixiJS",
    "frameworkIconText": "Pixi",
    "tags": [
      "pixijs",
      "performance",
      "object pooling",
      "memory management",
      "garbage collection"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Creating and destroying many objects frequently (e.g., bullets in a game, particles) can lead to performance issues due to garbage collection pauses. Object pooling is a technique where you pre-allocate a set of objects and reuse them instead of creating new ones and destroying old ones."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Conceptual Object Pool for Sprites\nclass SpritePool {\n  constructor(texture, initialSize = 100) {\n    this.texture = texture;\n    this.pool = [];\n    this.inUse = [];\n    for (let i = 0; i < initialSize; i++) {\n      this.pool.push(this._createSprite());\n    }\n  }\n\n  _createSprite() {\n    const sprite = new PIXI.Sprite(this.texture);\n    sprite.visible = false; // Initially not visible\n    // Set other default properties if needed\n    return sprite;\n  }\n\n  getSprite() {\n    let sprite;\n    if (this.pool.length > 0) {\n      sprite = this.pool.pop();\n    } else {\n      // Optionally grow pool or log warning\n      sprite = this._createSprite(); \n      console.warn('SpritePool had to create a new sprite.');\n    }\n    sprite.visible = true;\n    this.inUse.push(sprite);\n    app.stage.addChild(sprite); // Add to stage when taken from pool\n    return sprite;\n  }\n\n  releaseSprite(sprite) {\n    sprite.visible = false;\n    app.stage.removeChild(sprite); // Remove from stage when released\n    const index = this.inUse.indexOf(sprite);\n    if (index > -1) this.inUse.splice(index, 1);\n    this.pool.push(sprite);\n  }\n}\n\n// Usage:\n// const bulletTexture = await PIXI.Assets.load('assets/bullet.png');\n// const bulletPool = new SpritePool(bulletTexture, 50);\n\n// When firing a bullet:\n// const bullet = bulletPool.getSprite();\n// bullet.x = player.x; bullet.y = player.y; /* ... setup ... */\n\n// When bullet is off-screen or hits target:\n// bulletPool.releaseSprite(bullet);"
      },
      {
        "type": "explanation",
        "text": "The `SpritePool` maintains a list of available sprites (`pool`) and sprites currently in use (`inUse`). `getSprite()` retrieves a sprite from the pool (or creates one if the pool is empty). `releaseSprite()` returns a sprite to the pool, making it available for reuse, instead of destroying it. This reduces object creation/destruction overhead."
      }
    ],
    "quiz": {
      "snippet": "// When a particle effect finishes, instead of destroying each particle sprite:\n// particlePool.release(particleSprite);",
      "questionText": "What is the primary performance benefit of using an object pooling pattern in game development with PixiJS?",
      "options": [
        "It makes sprites automatically follow the mouse.",
        "It reduces the initial loading time of image assets.",
        "It reduces memory allocation/deallocation overhead and garbage collection pauses by reusing objects instead of frequently creating and destroying them.",
        "It automatically applies culling to off-screen objects."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "Object pooling helps improve performance by pre-allocating a set of objects and reusing them. This avoids the cost of repeatedly creating new objects and the subsequent garbage collection pauses that can occur when many objects are destroyed, which is common for short-lived entities like particles or bullets."
    }
  },
  {
    "id": "pixijs-advanced-render-texture-caching-003",
    "title": "Advanced Use of Render Textures for Caching & Effects",
    "difficulty": "advanced",
    "framework": "PixiJS",
    "frameworkIconText": "Pixi",
    "tags": [
      "pixijs",
      "render texture",
      "caching",
      "performance",
      "dynamic textures",
      "effects"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "Beyond simple caching, `PIXI.RenderTexture` can be used to create dynamic textures, apply effects to a group of objects as a single unit, or create visual feedback loops (e.g., trails, ripples). This involves rendering to the texture, then potentially using that texture on another sprite or as an input to a shader."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Assume 'app' is created.\n\n// Create a container for dynamic drawing\nconst dynamicDrawing = new PIXI.Container();\napp.stage.addChild(dynamicDrawing);\n\n// Create a RenderTexture to capture the drawing\nconst canvasSize = 200;\nconst brushTexture = PIXI.RenderTexture.create({ width: canvasSize, height: canvasSize });\nconst brushSprite = new PIXI.Sprite(brushTexture);\napp.stage.addChild(brushSprite);\nbrushSprite.position.set(300, 100);\n\n// Simple drawing interaction (e.g., on mouse move if interactive)\nlet lastPos = null;\napp.stage.interactive = true;\napp.stage.on('pointermove', (event) => {\n    if (event.buttons === 1) { // If left mouse button is down\n        const pos = event.global;\n        const brush = new PIXI.Graphics().beginFill(0xff0000).drawCircle(0,0,5).endFill();\n        brush.position.set(pos.x, pos.y);\n        dynamicDrawing.addChild(brush); // Add to a temporary container\n\n        // Render the dynamic drawings to the RenderTexture\n        // Do NOT clear if you want to accumulate drawings\n        app.renderer.render(dynamicDrawing, { renderTexture: brushTexture, clear: false });\n        // For performance, you might clear dynamicDrawing after rendering if not needed otherwise\n        // dynamicDrawing.removeChildren(); \n    }\n});\n\n// The brushSprite will now display the accumulated drawings."
      },
      {
        "type": "explanation",
        "text": "In this example, graphics are drawn into `dynamicDrawingContainer`. Then, this container is rendered to `brushTexture`. The `brushSprite` uses this `brushTexture`, effectively creating a dynamic drawing canvas. Setting `clear: false` in `renderer.render` allows drawings to accumulate on the render texture."
      }
    ],
    "quiz": {
      "snippet": "const rt = PIXI.RenderTexture.create({ width: w, height: h });\n// ... render complexContainer to rt ...\n// if (complexContainer.isModified) { renderer.render(complexContainer, {renderTexture: rt}); }\n// const cachedSprite = new PIXI.Sprite(rt);",
      "questionText": "If a complex `PIXI.Container` is rendered to a `PIXI.RenderTexture` only when its content changes, what performance benefit does this primarily offer when displaying the `RenderTexture` via a `PIXI.Sprite`?",
      "options": [
        "Reduces the download size of the initial application.",
        "Improves the resolution of the displayed graphics.",
        "Avoids re-rendering all individual child objects of the container on every frame if they haven't changed, by rendering a single cached texture (the sprite).",
        "Enables server-side rendering of the container."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "By rendering a complex, relatively static container to a RenderTexture, you create a cached bitmap. Displaying this bitmap (via a Sprite) is much faster than re-rendering all the individual children of the container on every frame, especially if those children are numerous or complex. You only need to update the RenderTexture when the source container's content actually changes."
    }
  },
  {
    "id": "pixijs-advanced-custom-mesh-shader-004",
    "title": "Custom Meshes and Shaders (`PIXI.Mesh`)",
    "difficulty": "advanced",
    "framework": "PixiJS",
    "frameworkIconText": "PixiGLSL",
    "tags": [
      "pixijs",
      "mesh",
      "custom geometry",
      "shaders",
      "PIXI.Geometry",
      "PIXI.Shader",
      "webgl"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "For highly custom 2D graphics, effects, or when needing direct control over vertices and shaders beyond what `PIXI.Graphics` or standard Sprites offer, you can use `PIXI.Mesh`. This requires defining a `PIXI.Geometry` (vertices, uvs, indices) and a `PIXI.Shader` (vertex and fragment GLSL shaders)."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Assume 'app' is created.\n\nconst geometry = new PIXI.Geometry()\n    .addAttribute('aVertexPosition', // attribute name\n        [-100, -100, //x, y\n          100, -100, //x, y\n          100,  100, //x, y\n         -100,  100], //x, y\n        2) // size: 2 components per vertex (x, y)\n    .addAttribute('aUvs', //  UVs for texture mapping\n        [0, 0, // u, v\n         1, 0, // u, v\n         1, 1, // u, v\n         0, 1], // u, v\n        2) // size: 2 components per vertex (u, v)\n    .addIndex([0, 1, 2, 0, 2, 3]); // Defines two triangles to form a quad\n\nconst vertexSrc = `\n    precision mediump float;\n    attribute vec2 aVertexPosition;\n    attribute vec2 aUvs;\n    uniform mat3 projectionMatrix;\n    varying vec2 vUvs;\n    void main() {\n        vUvs = aUvs;\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }`;\n\nconst fragmentSrc = `\n    precision mediump float;\n    varying vec2 vUvs;\n    uniform sampler2D uSampler; // For a texture\n    uniform float uTime;\n    void main() {\n        // Example: psychedelic color effect based on UVs and time\n        gl_FragColor = texture2D(uSampler, vUvs) * vec4(abs(sin(vUvs.x + uTime)), abs(cos(vUvs.y + uTime)), 0.5 + 0.5 * sin(uTime * 0.5), 1.0);\n        // Or just: gl_FragColor = texture2D(uSampler, vUvs);\n    }`;\n\n// const texture = await PIXI.Assets.load('assets/myTexture.png');\nconst uniforms = {\n    // uSampler: texture, \n    uTime: 0.0,\n};\n\nconst shader = PIXI.Shader.from(vertexSrc, fragmentSrc, uniforms);\nconst quadMesh = new PIXI.Mesh(geometry, shader);\nquadMesh.position.set(app.screen.width / 2, app.screen.height / 2);\napp.stage.addChild(quadMesh);\n\n// app.ticker.add(delta => { quadMesh.shader.uniforms.uTime += 0.01 * delta; });"
      },
      {
        "type": "explanation",
        "text": "`PIXI.Geometry` defines the mesh structure (vertices, UV coordinates, indices). `PIXI.Shader.from()` creates a shader program from GLSL vertex and fragment shader strings and uniforms. A `PIXI.Mesh` combines this geometry and shader. This offers maximum rendering flexibility."
      }
    ],
    "quiz": {
      "snippet": "const myGeo = new PIXI.Geometry();\nmyGeo.addAttribute('aVertexPosition', [0,0, 1,0, 0,1], 2);\nmyGeo.addIndex([0,1,2]);\nconst myShader = PIXI.Shader.from(vertSrc, fragSrc);\nconst myMesh = new PIXI.Mesh(myGeo, myShader);",
      "questionText": "When creating a custom `PIXI.Mesh`, what do the `addAttribute` and `addIndex` methods on `PIXI.Geometry` primarily define?",
      "options": [
        "Event listeners for the mesh.",
        "The material properties like color and texture.",
        "The vertex data (like positions, UVs) and the order in which vertices form triangles (indices), respectively.",
        "Animation keyframes for the mesh."
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "`addAttribute` is used to define vertex attributes such as positions (`aVertexPosition`), texture coordinates (`aUvs`), colors, etc. `addIndex` defines the indices that form triangles from the vertices, allowing for efficient rendering and vertex reuse."
    }
  },
  {
    "id": "pixijs-advanced-interaction-manager-005",
    "title": "Advanced Interaction Manager and Event Propagation",
    "difficulty": "advanced",
    "framework": "PixiJS",
    "frameworkIconText": "Pixi",
    "tags": [
      "pixijs",
      "interaction manager",
      "event propagation",
      "hitArea",
      "event bubbling"
    ],
    "type": "lesson_and_quiz",
    "lessonContent": [
      {
        "type": "paragraph",
        "text": "PixiJS's InteractionManager handles mouse and touch events. Understanding its details, like event propagation (bubbling), custom hit areas, and managing event listeners on nested objects, is key for complex UIs or games."
      },
      {
        "type": "code",
        "language": "javascript",
        "code": "// Assume 'app' is created\nconst parentContainer = new PIXI.Container();\nparentContainer.interactive = true; // Must be interactive to receive events or have children receive them through it\nparentContainer.x = 50; parentContainer.y = 50;\napp.stage.addChild(parentContainer);\n\nconst childSprite = PIXI.Sprite.from(PIXI.Texture.WHITE); // Simple white sprite\nchildSprite.width = 100; childSprite.height = 100;\nchildSprite.tint = 0xff0000; // Red\nchildSprite.interactive = true;\nchildSprite.cursor = 'pointer';\nparentContainer.addChild(childSprite);\n\n// Custom hitArea for the child (e.g., a circle for a rectangular sprite)\n// childSprite.hitArea = new PIXI.Circle(50, 50, 50); // x, y relative to sprite's origin, radius\n\nparentContainer.on('pointerdown', (event) => {\n  console.log('Parent container clicked. Target:', event.target, 'CurrentTarget:', event.currentTarget);\n  // event.stopPropagation(); // Call this to stop event from bubbling further up\n});\n\nchildSprite.on('pointerdown', (event) => {\n  console.log('Child sprite clicked. Target:', event.target, 'CurrentTarget:', event.currentTarget);\n  event.stopPropagation(); // Stop event from bubbling to parentContainer\n  childSprite.tint = Math.random() * 0xFFFFFF;\n});\n\n// Note: Pixi's default event propagation is similar to DOM bubbling.\n// The event is first dispatched on the target, then bubbles up its ancestors."
      },
      {
        "type": "explanation",
        "text": "Setting `interactive = true` on containers is important if their children need to receive events or if the container itself needs to. `event.target` refers to the object that originally dispatched the event, while `event.currentTarget` is the object the listener is attached to. `event.stopPropagation()` can prevent the event from bubbling up the display list. `hitArea` can define a custom shape for interaction detection, different from the object's visual bounds."
      }
    ],
    "quiz": {
      "snippet": "parent.interactive = true;\nchild.interactive = true;\nparent.addChild(child);\nparent.on('pointertap', () => console.log('Parent tapped'));\nchild.on('pointertap', (event) => {\n  console.log('Child tapped');\n  // What to call to prevent 'Parent tapped' from logging?\n});",
      "questionText": "In a PixiJS event handler on a child object, what method on the `event` object can be called to prevent the event from bubbling up to its parent containers?",
      "options": [
        "event.preventDefault()",
        "event.stopImmediatePropagation()",
        "event.stopPropagation()",
        "event.cancelBubble = true"
      ],
      "correctOptionIndex": 2,
      "explanationAfterAnswer": "`event.stopPropagation()` is used in an event listener to prevent the event from propagating (bubbling) further up the display object hierarchy to parent containers. `event.stopImmediatePropagation()` would also stop any other listeners on the *same* object from firing."
    }
  }
]
